コンテンツへとスキップする
チャット履歴

あなた:
async_.rs
ファイル
sync.rs
ファイル
https://files.seeedstudio.com/wiki/Grove-OLED-Display-1.12-(SH1107)_V3.0/res/SH1107V2.1.pdf SH1107Gのデータシート
https://github.com/peter-l5/SH1107 pythonのデバドラのリポジトリ
何か間違えているところがあったら指摘ください
ChatGPT:
保存されたメモリを更新しました
ありがとうございます。添付いただいた async_.rs と sync.rs のコードと、共有されたデータシート・Python 実装を踏まえて、あなたの sh1107g-rs ドライバに関して以下の観点でチェックを行いました：

✅ 正しく実装されている点
1. 初期化シーケンス
SH1107 データシート（V2.1）p.16 の「Power On and Display On Sequence」に従い、基本的なコマンド（Display OFF, Set Display Clock, Set Multiplex Ratio, Set Display Offset, など）が適切に送信されています。

Python ドライバと同様の順序・パラメータを採用しており、互換性が保たれています。

2. アドレス指定
.with_address(0x3C) を使用しており、Seeed Grove OLED モジュールで用いられるデフォルトの I2C アドレス（0x3C）に対応しています。

3. バッファ構造
buffer: [u8; 1024]（128x64/8）とページ単位での描画を行う形になっており、SH1107 のページモードと合致しています。

4. 非同期 / 同期 両対応
async 対応と blocking 対応を feature flag で切り替える設計は非常に理にかなっています（組み込み環境ではどちらも使われるため）。

⚠ 改善・修正を検討すべき点
1. Display Start Line の設定が一部不完全
データシートでは Set Display Start Line（0x40–0x7F, 上位ビットは0x40）を用いるよう記載があります。

0xDC, 0x00 は “Set Display Start Line” の拡張命令ですが、通常のコマンド（0x40 | n）で設定されるケースも多く、両対応を検討する価値があります。

2. Segment Remap & COM Scan Direction の扱い
0xA0（Segment Remap）や 0xC0（Common Output Scan Direction）の切り替えが固定値になっている点は、画面の上下・左右反転のニーズに応じてオプション化すると柔軟性が増します。

Python 実装では flip = True にするとこれを制御しています。

3. Display ON の直前に少し間をあけるべき
データシートには明示されていませんが、電源投入直後の初期化コマンドはデバイスの電源安定化を待って送るのが通例です（少し delay_ms を入れてもよい）。

特に VCC が外部供給の場合、初期化時にノイズや描画不良の可能性があるため、待機は有効です。

4. 充実した embedded-graphics 対応の範囲
DrawTarget 実装は最低限で、描画後に flush() 相当のものを自動的に呼ばない限り描画が反映されません。

flush() をどのように設計するか（明示的に呼ばせるか、内部で自動で呼ぶか）をユーザ視点で整理する必要があります。

5. I2C 書き込みの最大バイト数制限への配慮
一部マイコン（特に AVR）では I2C 一括送信バイト数が 32 bytes に制限されていることがあり、update_display() 時に chunks() で分割する設計が必要かもしれません。

Python ドライバでは bus.write_i2c_block_data を 1 ページ単位で送っています（0x40 + page_data）。

✅ その他良い点
Builder パターンの導入は柔軟な拡張がしやすく、SPI/I2C 両対応を目指す際にも役立ちます。

write_command, write_data を trait に分離すれば、Mock を使ったテストも可能になります。

提案まとめ
提案内容	優先度
Segment Remap / COM Output Direction のオプション化	★★★
Display Start Line の設定方式見直し	★★☆
flush() 設計ポリシーの明確化	★★☆
I2C 書き込みサイズの制限対応（特に AVR 向け）	★★☆
初期化前の delay (optional)	★☆☆
draw_target の自動 flush() 実行オプション化	★☆☆
必要であれば、個別のコード修正提案や PR 形式でも提示可能です。ご希望あればお知らせください。


あなた:
実機が光らなくて困ってるんだよね
ChatGPT:
なるほど、それは重要ですね。
**「I2C で認識されているのに、画面が光らない」**という状況には、主に以下の原因が考えられます。

✅ ハードウェア接続のチェックポイント
項目	内容
I2C アドレス	0x3C を使っている → OK（前回確認済）
VCC & GND	VCC = 3.3V or 5V、GND が正しく接続されているか？
VDD-VBAT	Grove モジュール（特に V3）では VDD/GND が安定して供給されていないと真っ暗になります
Pull-up 抵抗	I2C ラインにプルアップ（4.7kΩなど）が入っていないと通信は成功しても表示が動かないことがあります（特に ATmega + 手配線の場合）
RESET ピン	SH1107 はリセットされていないと何も描画されません。RESET ピンが HIGH になっているか確認してください（多くのモジュールでは内部で処理済み）
✅ ソフトウェア上でありがちな原因
1. Display ON コマンド (0xAF) を送っていない
これは最もよくある原因です。
0xAF を初期化シーケンスの最後に送っていますか？
→ Python 実装やデータシートでは、すべての設定のあとに 0xAF を送って表示を ON にしています。

2. 画面クリアしても表示しない
ディスプレイバッファが空（すべて0）だと、表示は真っ黒のままです。
→ 試しに 0xFF を詰めてみてください：

for b in buffer.iter_mut() {
    *b = 0xFF;
}
display.update_display().await?;
または、DrawTarget に fill_solid(&display.bounding_box(), RgbColor::WHITE) を試してください。

3. 表示位置がずれている
Set Display Offset（0xD3）や Set Display Start Line（0xDC）が正しく設定されていないと、表示内容が画面外になります。

デフォルトで次のようにしてみてください：

// Set Display Offset
write_command(0xD3)?;
write_command(0x60)?;  // 0x60 is typical for 128x64 SH1107
// Set Display Start Line
write_command(0xDC)?;
write_command(0x00)?;
✅ 確認の手順（再現性重視）
I2C 通信が通ってるか確認（済）

i2cdetect -y 1 → 0x3C に応答あり
Rust で 0xAF（Display ON） を送っているか確認

バッファに 0xFF を詰めて update_display() 実行しているか確認

I2C エラーや panic が起きていないか確認（Result::unwrap()してたら落ちてる可能性）

✅ デバッグヒント
**I2C モニタ（例えばロジアナ）**で 0xAF が送られているか、
または i2c_write にログを出すのも有効です。

例（ログ出力追加）:

fn write_command(&mut self, cmd: u8) -> Result<(), E> {
    let data = [0x00, cmd];
    log::info!("I2C write_command: {:02X}", cmd);
    self.i2c.write(self.address, &data)
}
🔧 それでも光らない場合
以下のコードを提供いただければ、さらに精査できます：

display.init().await の具体的な中身

update_display() の中身

draw_target を使っている場合はその呼び出し部

もしくは、「表示がされるようになるまで最小限のコードだけ」にしてくれれば、点灯するまで調整します。

やってみてもうまくいかなかった場合、「現状の main.rs 全体」を貼ってもらえると、最小構成で点灯するコードに調整できます。

あなた:
/* 
  PythonドライバとSH1107データシートから導出されたコマンド列
  コマンドを2バイトずつ（コマンドバイト + データバイト）送信
  ただし、0xAE, 0x20, 0xA0, 0xC0, 0xAF は単独コマンド
  そのため、cmds.chunks(2) の処理は注意が必要。
  個々のコマンドをsend_commandで送信するのがより確実。
*/

pub const DISPLAY_OFF: u8 = 0xAE;
pub const DISPLAY_ON: u8 = 0xAF;
pub const SET_MULTIPLEX_RATIO: u8 = 0xA8;
pub const MULTIPLEX_RATIO_DATA: u8 = 0x7F;
pub const CHARGE_PUMP_ON_CMD: u8 = 0xAD;
pub const CHARGE_PUMP_ON_DATA: u8 = 0x8B;
pub const PAGE_ADDRESSING_CMD: u8 = 0x20;
pub const SEGMENT_REMAP: u8 = 0xA0;
pub const COM_OUTPUT_SCAN_DIR: u8 = 0xC0;
pub const DISPLAY_START_LINE_CMD: u8 = 0xDC;
pub const DISPLAY_START_LINE_DATA: u8 = 0x00;
pub const CONTRAST_CONTROL_CMD: u8 = 0x81;
pub const CONTRAST_CONTROL_DATA: u8 = 0x2F;
pub const DISPLAY_OFFSET_CMD: u8 = 0xD3;
pub const DISPLAY_OFFSET_DATA: u8 = 0x60;
pub const PRECHARGE_CMD: u8 = 0xD9;
pub const PRECHARGE_DATA: u8 = 0x22;
pub const VCOM_DESELECT_CMD: u8 = 0xDB;
pub const VCOM_DESELECT_DATA: u8 = 0x35;
pub const CLOCK_DIVIDE_CMD: u8 = 0xD5;
pub const CLOCK_DIVIDE_DATA: u8 = 0x51;
ChatGPT:
ありがとうございます。この定義は非常に良く整理されており、Python 実装（peter-l5/SH1107）と SH1107 データシート V2.1 に忠実に基づいています。

ただし、この定義に基づいて初期化処理をしても画面が光らないということであれば、次の2つの可能性が高いです：

✅【重要】データバイト付きコマンドを chunks(2) で送っていると失敗する
コメントにも書いてあるとおり：

// cmd + data の組になってない単独コマンドが混在している
// → chunks(2) だと 0xAF や 0x20 などが欠落または無効に送られる
🔧 修正方法：個別に明示的に送る
以下のように、1コマンドずつ send_command(cmd) または send_command_with_data(cmd, data) を分けて送ることが最も安全です。

send_command(0xAE)?; // Display OFF

send_command_with_data(0xA8, 0x7F)?; // Multiplex Ratio
send_command_with_data(0xAD, 0x8B)?; // Charge Pump ON

send_command(0x20)?; // Page Addressing Mode

send_command(0xA0)?; // Segment remap
send_command(0xC0)?; // COM Output scan direction

send_command_with_data(0xDC, 0x00)?; // Display start line
send_command_with_data(0x81, 0x2F)?; // Contrast
send_command_with_data(0xD3, 0x60)?; // Display offset
send_command_with_data(0xD9, 0x22)?; // Precharge
send_command_with_data(0xDB, 0x35)?; // VCOM deselect
send_command_with_data(0xD5, 0x51)?; // Clock divide

send_command(0xAF)?; // ← Display ON（最も重要！）
✅ バッファ初期値が 0x00 → 真っ暗で「ついてないように見える」
SH1107 は初期化後もディスプレイバッファの内容を保持しています。
バッファが 0x00 で初期化されていた場合、正常に動作していても画面は真っ暗です。

🔧 試しに点灯確認するコード（必ず画面が真っ白になります）
for b in buffer.iter_mut() {
    *b = 0xFF; // 全点灯
}
display.update_display().await?; // flush相当
これでも光らない場合は、I2C 通信かハードウェアレベルで止まっています。

✅ よくある地雷
地雷	内容
chunks(2) に 0xAF が混ざる	→ 0xAF, 0xA8 → 0xA8 が data として解釈され失敗
Display ON (0xAF) を送っていない	→ 初期化成功しても光らない
update_display() を呼んでいない	→ バッファは更新されても表示に反映されない
0x00 バッファ	→ 真っ暗なので点灯していないように見える
delay を入れてない	→ 一部環境では電源安定しない
✅ まとめ：確実に光らせる最小コード例（同期版）
// 初期化コマンド（明示的に順番に送る）
send_command(0xAE)?;
send_command_with_data(0xA8, 0x7F)?;
send_command_with_data(0xAD, 0x8B)?;
send_command(0x20)?;
send_command(0xA0)?;
send_command(0xC0)?;
send_command_with_data(0xDC, 0x00)?;
send_command_with_data(0x81, 0x2F)?;
send_command_with_data(0xD3, 0x60)?;
send_command_with_data(0xD9, 0x22)?;
send_command_with_data(0xDB, 0x35)?;
send_command_with_data(0xD5, 0x51)?;
send_command(0xAF)?; // 最後に Display ON！

// バッファに全点灯データ
for b in buffer.iter_mut() {
    *b = 0xFF;
}
display.update_display()?; // flush 相当
これでも表示されない場合は、write() 関数にログを入れて実際に送られているバイト列を確認する必要があります。必要ならそのためのコードテンプレートも出します。

もう一歩絞り込むには、あなたの init() と update_display() の実装を見せてもらえると確実です。

あなた:
#![no_std]
#![no_main]

use arduino_hal::prelude::*;
use arduino_hal::{i2c, Peripherals};
use panic_halt as _;

use sh1107g_rs::{Sh1107gBuilder, DISPLAY_WIDTH, DISPLAY_HEIGHT};
use embedded_graphics::{
    mono_font::{ascii::FONT_6X10, MonoTextStyle},
    pixelcolor::BinaryColor,
    prelude::*,
    text::Text,
};

#[arduino_hal::entry]
fn main() -> ! {
    let dp = Peripherals::take().unwrap();
    let pins = arduino_hal::pins!(dp);

    let i2c = i2c::I2c::new(
        dp.TWI,
        pins.a4.into_pull_up_input(), // SDA (Uno: A4)
        pins.a5.into_pull_up_input(), // SCL (Uno: A5)
        100_000,
    );

    // OLED 初期化
    let mut display = Sh1107gBuilder::new()
        .connect_i2c(i2c)
        .with_address(0x3C)
        .build()
        .unwrap();

    display.init().unwrap();

    // "Hello!" を表示
    let text_style = MonoTextStyle::new(&FONT_6X10, BinaryColor::On);
    Text::new("Hello!", Point::new(16, 16), text_style)
        .draw(&mut display)
        .unwrap();

    display.flush().unwrap();
    arduino_hal::delay_ms(500); // 0.5秒だけ待つ

    loop {
        // 永久ループで終了させない
    }
} このコードで光らない
ChatGPT:
ありがとうございます！
提示いただいたコードは非常に明瞭で、一見問題がなさそうに見えますが、SH1107G（特に Grove モジュール）を光らせるには以下の点に注意が必要です。

✅ 問題の可能性：I2C 書き込みに失敗している／コマンドが正しく送られていない
なぜなら？
display.init().unwrap() や display.flush().unwrap() はすべて Result を返していますが、何が起きているかログが出ません。

panic_halt により何かエラーが起きて unwrap() で落ちた場合、LED が点滅したりせず無言で停止します（＝「光らない」状態に見える）

✅ やるべき最小限のデバッグチェック
① display.init() の直後に LED を点灯させる
→ もし init() に失敗していたら、このコードにたどり着きません。

pins.d13.into_output().set_high(); // Uno の LED を点灯
② バッファを全部 0xFF にして強制点灯させる
for y in 0..DISPLAY_HEIGHT {
    for x in 0..DISPLAY_WIDTH {
        display.set_pixel(x, y, true).unwrap(); // 全点灯
    }
}
display.flush().unwrap();
✅ それでも光らなければ… Sh1107gBuilder か init() の中身が原因です
あなたの sh1107g_rs ドライバが chunks(2) でコマンド送ってるなら、これは確実に失敗します。
さきほどの修正案通り、すべてのコマンドを1つずつ send_command() か send_command_with_data() で送るべきです。

✅ 確実に光らせる最小コード例（直接コマンドを送る）
以下のコードでディスプレイの I2C 接続と初期化手順が確実に合っているか検証できます：

let i2c = i2c::I2c::new(
    dp.TWI,
    pins.a4.into_pull_up_input(),
    pins.a5.into_pull_up_input(),
    100_000,
);
let address = 0x3C;
let mut i2cdev = linux_embedded_hal::I2cdev::new("/dev/i2c-1").unwrap();

// Display OFF
i2c.write(address, &[0x00, 0xAE]).unwrap();

// 必須設定（Multiplex, Offset, Clockなど）を個別に送る
i2c.write(address, &[0x00, 0xA8, 0x7F]).unwrap(); // Multiplex Ratio
i2c.write(address, &[0x00, 0xAD, 0x8B]).unwrap(); // Charge Pump ON
// ...略...

// Display ON
i2c.write(address, &[0x00, 0xAF]).unwrap();

// 真っ白バッファ送信（0x40 はデータモード）
for page in 0..8 {
    i2c.write(address, &[0x00, 0xB0 + page]).unwrap(); // Page Address Set
    i2c.write(address, &[0x00, 0x00]).unwrap();        // Lower column
    i2c.write(address, &[0x00, 0x10]).unwrap();        // Higher column
    let mut buf = [0xFF; 128 + 1];
    buf[0] = 0x40;
    i2c.write(address, &buf).unwrap();
}
✅ 対応方針の提案
状況	対処方法
unwrap()でpanicしてる可能性	display.init().expect("init failed"); に変えて様子を見る
コマンドが失敗してる可能性	sh1107g_rs の init() を一時的に手動に書き換えてテスト
I2C 書き込みが一部失敗している	コマンドを send_command() で1個ずつ明示的に送るよう修正
✅ 必要ならこちらで sh1107g_rs に修正 PR 提出可能
「最小で光る init() 実装」や「ページごとのバッファ送信」など、こちらで Rust ドライバ修正提案出せます。希望される場合は init() の中身だけ貼ってもらえれば修正版を提示します。

💡 とにかく今の段階で一番重要なのは：

display.init() の成功可否をログで確認する

0xAF が送られているか確認する

バッファが 0xFF になっているか確認する

この3点です。それでもダメなら init() の中身をください。光らせるまで付き合います。

あなた:
error[E0277]: embedded_graphics::geometry::Point is not an iterator
   --> src/main.rs:39:27
    |
39  | ...   display.draw_iter(Point::new(x as i32, y as i32), BinaryColor::On...
    |               --------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ embedded_graphics::geometry::Point is not an iterator
    |               |
    |               required by a bound introduced by this call
    |
    = help: the trait Iterator is not implemented for embedded_graphics::geometry::Point
    = note: required for embedded_graphics::geometry::Point to implement IntoIterator
note: required by a bound in draw_iter
   --> /home/placeless/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/embedded-graphics-core-0.4.0/src/draw_target/mod.rs:304:12
    |
302 |     fn draw_iter<I>(&mut self, pixels: I) -> Result<(), Self::Error>
    |        --------- required by a bound in this associated function
303 |     where
304 |         I: IntoIterator<Item = Pixel<Self::Color>>;
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in DrawTarget::draw_iter

error[E0061]: this method takes 1 argument but 2 arguments were supplied
   --> src/main.rs:39:17
    |
39  | ...play.draw_iter(Point::new(x as i32, y as i32), BinaryColor::On).unwr...
    |         ^^^^^^^^^                                 --------------- unexpected argument #2 of type BinaryColor
    |
note: method defined here
   --> /home/placeless/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/embedded-graphics-core-0.4.0/src/draw_target/mod.rs:302:8
    |
302 |     fn draw_iter<I>(&mut self, pixels: I) -> Result<(), Self::Error>
    |        ^^^^^^^^^
help: remove the extra argument
    |
39  -         display.draw_iter(Point::new(x as i32, y as i32), BinaryColor::On).unwrap(); // 全点灯
39  +         display.draw_iter(Point::new(x as i32, y as i32)).unwrap(); // 全点灯
    |

warning: unused import: arduino_hal::prelude
ChatGPT:
ありがとうございます！
表示用コードで出ているこのエラーは、embedded-graphics の使い方の誤解釈によるものです。以下で解説と修正版コードを提示します。

❌ 今のエラーの原因
display.draw_iter(Point::new(x as i32, y as i32), BinaryColor::On).unwrap();
この行は間違いで、draw_iter() は **「Pixelのイテレータ」**を引数に取る関数です。

Point::new(...) は Iterator ではない → IntoIterator の実装がなくてコンパイルエラー。

2つ目の引数 BinaryColor::On は不要。

✅ どう書けばいい？
DrawTarget に 1ピクセル描画する正しい方法は：
use embedded_graphics::Pixel;

let _ = display.draw_iter(core::iter::once(
    Pixel(Point::new(x, y), BinaryColor::On),
));
またはもっと簡単に：

display.set_pixel(x as u32, y as u32, true).unwrap(); // ← sh1107g-rs にこの関数があればこっちがベスト
✅ 提案：全点灯するコードの修正版
for y in 0..DISPLAY_HEIGHT {
    for x in 0..DISPLAY_WIDTH {
        let _ = display.draw_iter(core::iter::once(
            Pixel(Point::new(x as i32, y as i32), BinaryColor::On),
        ));
    }
}
display.flush().unwrap();
もし draw_iter() が遅い／遅延が問題なら、内部バッファに直接書くために set_pixel(x, y, true) をドライバに追加するほうが高速です。

✅ unused import 警告について
warning: unused import: `arduino_hal::prelude`
arduino_hal::prelude::* を使っていない（つまり .into_output() など prelude 経由で使ってない）というだけなので、削除して構いません：

// 削除してOK
// use arduino_hal::prelude::*;
✅ まとめ
問題	解決策
draw_iter に Point を渡してる	Pixel(Point, Color) のイテレータを渡す
ピクセルを1つだけ描きたい	set_pixel(x, y, true) か draw_iter(core::iter::once(...))
prelude unused warning	不要なら削除してOK
もし set_pixel() を使いたいのに存在しない場合、sh1107g-rs に追加できます。必要であればその PR 提案も出します。

あなた:
/// Rendering
    // Send self internal buffer
    pub async fn flush_async(&mut self) -> Result<(), E> {
        // SH1107Gはページアドレッシングモードで、各ページ128バイト
        // 128x128ピクセルなので、128/8 = 16ページ
        for page in 0..16 { // 0から15ページまで
            self.send_cmd_async(0xB0 + page).await?; // Set Page Address (B0h ~ BFh)
            self.send_cmd_async(0x00).await?; // Set Lower Column Address (0x00)
            self.send_cmd_async(0x10).await?; // Set Higher Column Address (0x10)

            // 各ページ128バイトのデータを送信
            // buffer は2048バイト全体で、各ページ128バイトなので
            // buffer[page * 128 .. (page + 1) * 128] で該当ページのスライスを取得

            // page も usize にキャストして演算
            let page_usize = page as usize; // <-- ここでusizeにキャスト
            let width_usize = DISPLAY_WIDTH as usize; // <-- ここもusizeにキャスト

            // インデックス計算をusizeで行う
            let start_index = page_usize * (width_usize / 8);
            let end_index = (page_usize + 1) * (width_usize / 8);

            // スライスもusizeの範囲で指定
            // 内部バッファ保持
            let page_data = &self.buffer[start_index..end_index];

            // I2Cのwriteは1回の呼び出しで送信できるデータ量に制限がある場合があるため、
            // 16バイトずつ分割して送信するロジックは理にかなっている。
            // 各ページのデータを16バイトチャンクで送信
            for chunk in page_data.chunks(16) {
                let mut buf: heapless::Vec<u8, 17> = heapless::Vec::new(); // 制御バイト1 + データ最大16バイト
                buf.push(0x40).unwrap(); // control byte for data (0x40)
                buf.extend_from_slice(chunk).unwrap();
                self.i2c.write(self.address, &buf).await?;
            }
        }
        Ok(())
    }
}
ChatGPT:
ありがとうございます。
この flush_async() 実装は SH1107G 向けにかなり正確に設計されており、全体として正しい構造です。
ただし、表示されない（光らない）原因があるとすれば、以下のいずれかです：

✅ flush_async() の確認まとめ
要素	内容	問題の有無
ページループ	0..16 → 128px の縦解像度を 8px/p（＝16ページ）でカバー → ✅	
アドレス設定	0xB0 + page, 0x00, 0x10 → 正しい初期化順 → ✅	
ページデータ取得	buffer[page * 128..(page + 1) * 128] → 合理的 → ✅	
チャンク送信	16バイト + 制御バイト 0x40 で送信 → ✅	
Vec サイズ	heapless::Vec<u8, 17> で 16 + 1 byte → ✅	
非同期対応	.await を使って write() 呼び出し → ✅	
❗️可能性①：self.buffer に 0 が入っている
描画前に何も書き込まれていない場合、バッファはゼロのままで真っ黒です。
flush_async() の問題ではなく、描画関数で self.buffer が書き変わっていない可能性があります。

✅ チェック方法（テスト用に全点灯）
for byte in self.buffer.iter_mut() {
    *byte = 0xFF;
}
self.flush_async().await?;
❗️可能性②：初期化コマンド (init_async()) が不完全または失敗している
flush_async() が正しくても、display.init_async().await? がコケていれば、ディスプレイは無反応です。

初期化コマンド中で 0xAF（Display ON）を送っていない場合も同様。

✅ チェックポイント：

self.send_cmd_async(0xAE).await?; // Display OFF

// ...必要な初期化コマンドをすべて送る...

self.send_cmd_async(0xAF).await?; // ← Display ON を最後に送っているか？
❗️可能性③：I2C 書き込み失敗（特に AVR 環境）
問題の背景
AVR (ATmega328pなど) の I2C 実装では 一度に送れるデータ長に制限（32バイトなど） がある場合があります。

flush_async() は 17バイトずつにチャンクされていて対応済のように見えますが、Arduino HAL 側が .write() に内部エラーを返していないか確認が必要です。

✅ テスト方法
送信の各箇所にログを追加してみてください：

// 追加：
defmt::info!("Sending {} bytes to {:X}", buf.len(), self.address);
あるいは .await? を .await.expect("I2C write failed") に変えることで panic を捕まえることもできます。

✅ 結論：表示されない原因を切り分けるステップ
バッファを 0xFF で初期化してみる → 本当に送れてるか確認

flush_async() に panic や Err(_) が返ってないかログ出力

init_async() の中で 0xAF を最後に送ってるかチェック

flush_async() の write() に .expect("write failed") をつけてみる

最終手段：I2C の送信内容をロジアナで見る（if available）

💡もしよければ init_async() の中身も見せてください
flush_async() は合格点です。初期化が原因の可能性が最も高いです。
また、「同期版の flush()」もお持ちなら、それと比較することもできます。

あなた:
/* 
  PythonドライバとSH1107データシートから導出されたコマンド列
  コマンドを2バイトずつ（コマンドバイト + データバイト）送信
  ただし、0xAE, 0x20, 0xA0, 0xC0, 0xAF は単独コマンド
  そのため、cmds.chunks(2) の処理は注意が必要。
  個々のコマンドをsend_commandで送信するのがより確実。
*/

pub const DISPLAY_OFF: u8 = 0xAE;
pub const DISPLAY_ON: u8 = 0xAF;
pub const SET_MULTIPLEX_RATIO: u8 = 0xA8;
pub const MULTIPLEX_RATIO_DATA: u8 = 0x7F;
pub const CHARGE_PUMP_ON_CMD: u8 = 0xAD;
pub const CHARGE_PUMP_ON_DATA: u8 = 0x8B;
pub const PAGE_ADDRESSING_CMD: u8 = 0x20;
pub const SEGMENT_REMAP: u8 = 0xA0;
pub const COM_OUTPUT_SCAN_DIR: u8 = 0xC0;
pub const DISPLAY_START_LINE_CMD: u8 = 0xDC;
pub const DISPLAY_START_LINE_DATA: u8 = 0x00;
pub const CONTRAST_CONTROL_CMD: u8 = 0x81;
pub const CONTRAST_CONTROL_DATA: u8 = 0x2F;
pub const DISPLAY_OFFSET_CMD: u8 = 0xD3;
pub const DISPLAY_OFFSET_DATA: u8 = 0x60;
pub const PRECHARGE_CMD: u8 = 0xD9;
pub const PRECHARGE_DATA: u8 = 0x22;
pub const VCOM_DESELECT_CMD: u8 = 0xDB;
pub const VCOM_DESELECT_DATA: u8 = 0x35;
pub const CLOCK_DIVIDE_CMD: u8 = 0xD5;
pub const CLOCK_DIVIDE_DATA: u8 = 0x51;

/// sync
#[cfg(feature = "sync")]
use embedded_hal::i2c::I2c;

#[cfg(feature = "sync")]
use crate::{cmds::*, BuilderError, Sh1107g, Sh1107gBuilder, DISPLAY_WIDTH};

#[cfg(feature = "sync")]
use core::result::Result;
#[cfg(feature = "sync")]
use core::result::Result::Ok;

// Sh1107g instance ( builded by builder ) call init and flush
#[cfg(feature = "sync")]
impl<I2C, E> Sh1107gBuilder<I2C>
where
    I2C: embedded_hal::i2c::I2c<Error = E>,
{
    /// Build Sh1107g instance
    pub fn build(self) -> Result<Sh1107g<I2C>, BuilderError> {
        let i2c = self.i2c.ok_or(BuilderError::NoI2cConnected)?;
        // let size = self.size.ok_or(BuilderError::NoDisplaySizeDefined)?; // サイズが必須の場合

        // If you need, more add configure

        let oled = Sh1107g::new(i2c, self.address
            // size: size,
            // rotation: self.rotation,
            ); // Sh1107g::new init include buffer

        // display initialize やるかどうか
        Ok(oled)
    }
}

// Sh1107g impl block
#[cfg(feature = "sync")]
impl<I2C, E> Sh1107g<I2C>
where
    I2C: I2c<Error = E>,
{
    /// Display initialize sequence
    pub fn init(&mut self) -> Result<(), E> {
        self.send_cmd(DISPLAY_OFF)?; // Display Off
        self.send_cmdandarg(0xD5, 0x51)?; // Set Display Clock Divide Ratio / Osc Frequency (Pythonで0x51)
        self.send_cmdandarg(SET_MULTIPLEX_RATIO, MULTIPLEX_RATIO_DATA)?; // Set Multiplex Ratio (128行対応)
        self.send_cmdandarg(DISPLAY_OFFSET_CMD, DISPLAY_OFFSET_DATA)?; // Set Display Offset (Pythonで0x60)
        self.send_cmdandarg(CHARGE_PUMP_ON_CMD, CHARGE_PUMP_ON_DATA)?; // Set Charge Pump (Pythonで0x8B, データシートでは8BhがEnable)
        self.send_cmdandarg(0xDA, 0x12)?; // Set COM Pins Hardware Config (Pythonで0x12)
        self.send_cmd(PAGE_ADDRESSING_CMD)?; // Set Memory Addressing Mode (Page Addressing Mode)
        self.send_cmd(CONTRAST_CONTROL_CMD)?; // Set Contrast Control
        self.send_cmdandarg(CONTRAST_CONTROL_CMD, CONTRAST_CONTROL_DATA)?; // Contrast Control (0x2Fは一般的な値)
        self.send_cmd(0xA0)?; // Set Segment Remap (通常はA0hかA1h)
        self.send_cmd(0xC0)?; // Set COM Output Scan Direction (C0h: Normal, C8h: Re-mapped)
        self.send_cmdandarg(0xD9, 0x22)?; // Set Pre-charge Period
        self.send_cmdandarg(0xDB, 0x35)?; // Set VCOM Deselect Level
        self.send_cmd(0xA4)?; // Set Entire Display ON / OFF (A4h: Normal Display)
        self.send_cmd(0xA6)?; // Set Normal / Inverse Display (A6h: Normal)
        self.send_cmd(DISPLAY_ON)?; // Display ON

        Ok(())
    }

    /// IIC write command byte
    fn send_cmd(&mut self, cmd: u8) -> Result<(), E> {
        self.i2c.write(self.address, &[0x00, cmd])
    }

    /// IIC write command byte and data byte
    fn send_cmdandarg(&mut self, cmd: u8, arg: u8) -> Result<(), E> {
        self.i2c.write(self.address, &[0x00, cmd, arg])
    }

    /// Rendering
    // Send self internal buffer
    pub fn flush(&mut self) -> Result<(), E> {
        // SH1107G is page addressing mode and 128 byte/page
        // 128/8 = 16 page because 128x128 pixels
        for page in 0..16 { // 0 to 15
            self.send_cmd(0xB0 + page)?; // Set Page Address (B0h ~ BFh)
            self.send_cmd(0x00)?; // Set Lower Column Address (0x00)
            self.send_cmd(0x10)?; // Set Higher Column Address (0x10)

            // buffer は2048バイト全体で、各ページ128バイトなので
            // buffer[page * 128 .. (page + 1) * 128] で該当ページのスライスを取得

            // Cast to usize and perform calculation
            let page_usize = page as usize;
            let width_usize = DISPLAY_WIDTH as usize;

            let start_index = page_usize * (width_usize / 8);
            let end_index = (page_usize + 1) * (width_usize / 8);

            // スライスもusizeの範囲で指定
            // 内部バッファ保持
            let page_data = &self.buffer[start_index..end_index];

            // I2Cのwriteは1回の呼び出しで送信できるデータ量に制限がある場合があるため、
            // 16バイトずつ分割して送信するロジックは理にかなっている。
            // 各ページのデータを16バイトチャンクで送信
            for chunk in page_data.chunks(16) {
                let mut buf: heapless::Vec<u8, 17> = heapless::Vec::new(); // 制御バイト1 + データ最大16バイト
                buf.push(0x40).unwrap(); // control byte for data (0x40)
                buf.extend_from_slice(chunk).unwrap();
                self.i2c.write(self.address, &buf)?;
            }
        }
        Ok(())
    }
}
ChatGPT:
ありがとうございます、コードと情報を確認しました。以下は、SH1107G ディスプレイが点灯しない可能性のある原因と、それに対する改善案・検証ポイントです。

✅ コード上の良い点
データシートとPython実装に忠実で、初期化手順はほぼ問題ありません。

send_cmd() と send_cmdandarg() を明確に使い分けている。

flush() 内の page 書き込みロジックも正しい（SH1107 はページアドレッシング）。

I2C アドレスを 0x3C にしている（i2cdetect にも応答あり）。

⚠️ 実機が光らない原因候補と改善策
1. DISPLAY_OFFSET が大きすぎる
self.send_cmdandarg(DISPLAY_OFFSET_CMD, 0x60)?; // Pythonでは0x60
🧪 対策：
まず 0x00 にして試してみてください。

0x60 は「ディスプレイRAMの始点を物理位置からずらす」という意味で、SH1107G では実装依存です。

一般的には 0x00 or 0x20 くらいが無難です。

2. CHARGE_PUMP の 0x8B が Seeed 製モジュールに未対応の可能性
self.send_cmdandarg(CHARGE_PUMP_ON_CMD, 0x8B)?;
🧪 対策：
公式データシートでは 0x8B = 内蔵 + 自動制御。

代わりに 0x14（内蔵 VCC） を試す：

self.send_cmdandarg(CHARGE_PUMP_ON_CMD, 0x14)?;
3. 初期化順序の微調整
一部のOLEDでは DISPLAY_ON を早く呼ぶと動かないことがあります。

🧪 対策：
DISPLAY_ON は最後に。

一方 DISPLAY_OFF は一番最初で問題ありません。

4. flush() 実行前に init() 済みか
描画しようとしても初期化されていないと何も起きません。

🧪 対策：
build() した後、init() を必ず明示的に呼ぶ。

let mut display = builder.build().unwrap();
display.init().unwrap();
5. I2C通信が途中で止まっている
特に heapless::Vec の unwrap() に .ok() を使わずクラッシュしている可能性。

🧪 対策：
一時的に unwrap() を expect("I2C write failed") に変更してデバッグ。

6. コントラスト設定（0x2F）が低すぎる？
0x2F はかなり暗い場合があります。

🧪 対策：
試しに 0xFF にしてみてください：

self.send_cmdandarg(CONTRAST_CONTROL_CMD, 0xFF)?;
7. Pull-up 抵抗が足りない
Groveケーブルは内部にプルアップがあることもありますが、ない場合は SCL/SDA に 4.7kΩ～10kΩのプルアップ抵抗が必要です。

✅ 確認すべきこと一覧（ToDo）
項目	現状	確認 or 修正内容
I2Cアドレス	0x3C	i2cdetect で応答あり → OK
初期化コマンド	データシート＋Python準拠	DISPLAY_OFFSET を 0x00 に変える
Charge Pump	0x8B	0x14 でも試す
コントラスト	0x2F	0xFF にして変化を確認
Flush	書き込み済み	init() の呼び出し忘れなし？
プルアップ抵抗	不明	回路図またはテスターで確認
🔧 最小再現コード（initだけで表示確認）
let mut display = builder.build().unwrap();
display.init().unwrap();

for i in 0..=2047 {
    display.buffer[i] = 0xFF; // 全面白
}
display.flush().unwrap();
必要であれば init() の I2C ログ出力や、oscilloscope 的な I2Cモニタのアドバイスもできます。

もし上記試してもダメだったら、init() の呼び出し直後に flush() して 全白表示 が出るか確認して教えてください。

あなた:
field buffer of Sh1107g is privaterust-analyzerE0616
field buffer of struct Sh1107g is private
private fieldrustcClick for full compiler diagnostic
sh1107g_rs::Sh1107g
buffer: [u8; BUFFER_SIZE]
I2C = I2c<Atmega, TWI, Pin<…, …>, …, …>

ライブラリ側でpub 指定してるんですが
ChatGPT:
rust-analyzer や rustc が「buffer は private」と言ってくる原因は、Sh1107g 構造体の buffer フィールドに pub が正しく付いていないか、可視性が制限されているためです。

✅ チェックすべきこと
1. 定義元の Sh1107g 構造体のフィールドに pub が付いているか？
たとえば、以下のようになっていないといけません：

pub struct Sh1107g<I2C> {
    pub buffer: [u8; BUFFER_SIZE], // ←これが必要
    pub i2c: I2C,
    pub address: u8,
}
もし pub(crate) や pub(super) などで宣言されていると、外からアクセスできません。

2. mod や use の階層から見て、Sh1107g 構造体が定義されているモジュールに可視性の問題がないか？
たとえば、Sh1107g が driver モジュールにある場合、以下のように use していても buffer にアクセスできないことがあります：

// NG例：buffer が pub でないとアクセスできない
use crate::driver::Sh1107g;

fn foo(oled: &mut Sh1107g<_>) {
    oled.buffer[..]; // ←エラー
}
🧪 解決法
✅ 方法1: buffer を pub にする
pub struct Sh1107g<I2C> {
    pub buffer: [u8; BUFFER_SIZE], // ←これ！
    // 他のフィールド
}
✅ 方法2: flush() メソッドの中で buffer にアクセスするようにして、外からアクセスしない
impl<I2C, E> Sh1107g<I2C>
where
    I2C: I2c<Error = E>,
{
    pub fn flush(&mut self) -> Result<(), E> {
        // self.buffer に直接アクセスするなら pub は不要
    }
}
📌 補足：設計的に正しいのは？
一般的に、buffer は 外部から直接アクセスさせず、flush() などのメソッドを通じて扱う方が安全です。
そのため、以下の設計がおすすめです：

struct Sh1107g<I2C> {
    buffer: [u8; BUFFER_SIZE], // pub にしない
    i2c: I2C,
    address: u8,
}

impl<I2C, E> Sh1107g<I2C> {
    pub fn update_buffer(&mut self, new: &[u8]) {
        self.buffer.copy_from_slice(new);
    }

    pub fn flush(&mut self) -> Result<(), E> {
        // buffer に内部でアクセス
    }
}
もし pub にしているコードがあるのにアクセスできないという場合は、該当部分のコードを見せてくれたらピンポイントで確認できます。

あなた:
#![no_std]
/// SH1107G I2C OLED driver
pub mod cmds;

#[cfg(feature = "sync")]
pub mod sync;

#[cfg(feature = "async_")]
pub mod async_;

use embedded_graphics_core::{
    draw_target::DrawTarget,
    pixelcolor::BinaryColor,
    Pixel,
};
use core::convert::Infallible;
use core::result::Result;
use core::option::Option::{self, Some, None};
use core::result::Result::Ok;
use core::fmt::Debug;
use core::iter::IntoIterator;

/*
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DisplayRotation {
    Rotate0,
    Rotate90,
    Rotate180,
    Rotate270,
}

// Default process
impl Default for DisplayRotation {
    fn default() -> Self {
        DisplayRotation::Rotate0
    }
}
*/

/// common
use embedded_graphics_core::geometry::{Dimensions, Point, Size};

pub struct Sh1107g<I2C> {
    i2c: I2C,
    address: u8,
    buffer: [u8; BUFFER_SIZE], // Internal buffer
    // Configure in builder to Sh1107g struct
}

impl <I2C> Sh1107g<I2C> {
    // Make new driver instance & Degine function called by the builder
    // Initialise the internal buffer when called by builder
    pub fn new(i2c: I2C, address: u8) -> Self {
        Self {
            i2c,
            address,
            buffer: [0x00; BUFFER_SIZE], // 全てオフで初期化
        }
    }

    /// 内部バッファをクリアする
    pub fn clear_buffer(&mut self) {
        self.buffer.iter_mut().for_each(|b| *b = 0x00);
    }
}
// Builder struct
pub struct Sh1107gBuilder<I2C> {
    i2c: Option<I2C>,
    address: u8,      // Configure default address or choice Option type
    // If you can add more settings value rotation: DisplayRotation,etc...
}

// Sh1107gBuilder implement block
impl<I2C> Sh1107gBuilder<I2C> {
    /// Make new builder instance
    /// Designation default I2C address
    pub fn new() -> Self {
        Self {
            i2c: None,
            address: 0x3C, // default
            // size: None,
            // rotation: DisplayRotation::default(),
        }
    }

    /// Connect I2C
    pub fn connect_i2c(mut self, i2c: I2C) -> Self {
        self.i2c = Some(i2c);
        self
    }

    /// Configure I2C address
    pub fn with_address(mut self, address: u8) -> Self {
        self.address = address;
        self
    }

    // If you need other method, add other setting method, example: size,rotate,etc...
}

// Define error enum in builder
#[derive(Debug)]
pub enum BuilderError {
    NoI2cConnected,
    // NoDisplaySizeDefined, // サイズが必須の場合
}
// embedded-halのErrorトレイトにも対応させる必要があるかもしれません
// impl embedded_hal::i2c::Error for BuilderError { ... }
// impl From<BuilderError> for YourDriverError { ... } など

// define display size
pub const DISPLAY_WIDTH: u32 = 128;
pub const DISPLAY_HEIGHT: u32 = 128;
pub const BUFFER_SIZE: usize = (DISPLAY_WIDTH * DISPLAY_HEIGHT / 8) as usize;

// Sh1107g に Dimensions トレイトを実装
impl<I2C> Dimensions for Sh1107g<I2C> {
    fn bounding_box(&self) -> embedded_graphics_core::primitives::Rectangle {
        embedded_graphics_core::primitives::Rectangle::new(
            Point::new(0, 0),
            Size::new(DISPLAY_WIDTH, DISPLAY_HEIGHT),
        )
    }
}

impl<I2C> DrawTarget for Sh1107g<I2C> {
    // DrawTarget define color dimension (monochro OLED = BinaryColor)
    type Color = BinaryColor;
    type Error = Infallible; // embedded-halのI2Cエラーをそのまま使う
    
    /// ピクセルを描画する主要なメソッド
    fn draw_iter<PIXELS>(&mut self, pixels: PIXELS) -> Result<(), Self::Error>
    where
        PIXELS: IntoIterator<Item = Pixel<Self::Color>>,
    {
        for Pixel(Point { x, y }, color) in pixels {
            // 座標がディスプレイ範囲内かチェック
            if x < 0 || x >= DISPLAY_WIDTH as i32 || y < 0 || y >= DISPLAY_HEIGHT as i32 {
                continue; // 範囲外のピクセルはスキップ
            }

            // ピクセル座標からバッファのインデックスとビットマスクを計算
            // SH1107Gはページアドレッシングモードで、各バイトが縦8ピクセル
            let byte_index = (x as usize) + (y as usize / 8) * (DISPLAY_WIDTH as usize);
            let bit_mask = 1 << (y % 8); // バイト内のビット位置

            // バッファの範囲チェック（念のため）
            if byte_index >= BUFFER_SIZE {
                continue; // バッファ範囲外もスキップ
            }

            // 色に応じてバッファのビットをセットまたはクリア
            match color {
                BinaryColor::On => self.buffer[byte_index] |= bit_mask,  // ピクセルをON (セット)
                BinaryColor::Off => self.buffer[byte_index] &= !bit_mask, // ピクセルをOFF (クリア)
            }
        }
        Ok(())
    }

    /// Fill in with color
    fn clear(&mut self, color: Self::Color) -> Result<(), Self::Error> {
        let fill_byte = match color {
            BinaryColor::On => 0xFF,
            BinaryColor::Off => 0x00,
        };
        self.buffer.iter_mut().for_each(|b| *b = fill_byte);
        Ok(())
    }
}
ChatGPT:
buffer フィールドが private でアクセスできないというエラーは、以下のようなケースで発生します：

✅ 原因
pub struct Sh1107g<I2C> {
    i2c: I2C,
    address: u8,
    buffer: [u8; BUFFER_SIZE], // ← pub がついていないため private 扱い
}
つまり、buffer フィールドが pub ではないため、モジュール外（例：async_ モジュール）からアクセスできないのが原因です。

✅ 対処法 3つ
① 最も簡単な対応：pub(crate) にする
ライブラリ内でアクセスしたい場合は、これでOK：

pub(crate) buffer: [u8; BUFFER_SIZE],
これにより、同じクレート内（= sh1107g-rs の中）であれば async_ モジュールなどから buffer にアクセス可能になります。

② 完全に公開したいなら：pub にする
pub buffer: [u8; BUFFER_SIZE],
⚠ ただしこれは、ライブラリ使用者（外部 crate）にも完全に公開されてしまうので注意が必要です。

③ getter メソッドを提供する
もし外から読み取り専用で使いたいだけなら：

impl<I2C> Sh1107g<I2C> {
    pub fn buffer(&self) -> &[u8] {
        &self.buffer
    }

    pub fn buffer_mut(&mut self) -> &mut [u8] {
        &mut self.buffer
    }
}
✅ 推奨される方針
ライブラリ設計の観点から：
ライブラリ内部だけでアクセスしたい → pub(crate)

本当に外部 crate にも公開したい → pub

読み取りや書き込みを制限したい → getter/setter メソッドを設ける

🛠 例：pub(crate) に変更
pub struct Sh1107g<I2C> {
    pub(crate) i2c: I2C,
    pub(crate) address: u8,
    pub(crate) buffer: [u8; BUFFER_SIZE], // ← これ
}
このようにすれば、mod async_ 内の flush_async 関数から self.buffer[...] を問題なく使えるようになります。

必要であれば、flush_async を定義している async_ モジュールとの依存関係や mod.rs 構成についても見直すことは有益です。希望があればその部分も確認します。

あなた:
 // Each page is 128 bytes. Get the slice for the current page.
            let page_usize = page as usize;
            let width_usize = DISPLAY_WIDTH as usize;
            // Calculate start and end indices for the current page.
            let start_index = page_usize * width_usize;
            let end_index = (page_usize + 1) * width_usize;
といった提案もされています
ChatGPT:
ありがとうございます。状況は以下のように整理できます：

❗ 現在の問題
コードはビルドでき、I2C アドレス 0x3C に応答もあるが、SH1107G OLED が全く光らない。

✅ ハードウェアチェック済み項目
I2C 接続は 0x3C に反応している → OK

init() → flush() 呼び出しあり → OK

display に Text::new(...).draw(...) → OK

sh1107g_rs ドライバは自作中 → OK

✅ ソフトウェア構造の現状
Sh1107g<I2C> の buffer は DrawTarget と clear により操作されている

flush() を呼ぶことで buffer → デバイス に転送される想定

ただし、実際にデバイスに何も送っていない可能性が高い

🛠️ 根本的な原因
おそらく次の2点のうち少なくとも1つ：

① flush() の実装がまだ存在しない、あるいは draw() で変更された buffer を OLED に反映していない
display.flush().unwrap();
これは Sh1107g<I2C> の flush() メソッドで self.buffer を I2C で送信する処理が書かれている 必要があります。

しかし、あなたの提示してくれたコード中に flush() の定義が見当たりません。

✅ 対応策：flush() 実装の追加
Sh1107g 構造体に flush() メソッドを定義してください：

use embedded_hal::blocking::i2c::Write;

impl<I2C, E> Sh1107g<I2C>
where
    I2C: Write<Error = E>,
{
    pub fn flush(&mut self) -> Result<(), E> {
        for page in 0..(DISPLAY_HEIGHT / 8) {
            let page = page as u8;
            let cmds = [
                0xB0 + page,        // Set page start address
                0x02,               // Lower column address
                0x10,               // Higher column address
            ];
            self.i2c.write(self.address, &cmds)?;

            let start = (page as usize) * DISPLAY_WIDTH as usize;
            let end = start + DISPLAY_WIDTH as usize;

            // OLEDに書き込む際は、0x40をデータコントロールバイトとして先頭に付加
            let mut data = [0u8; 1 + DISPLAY_WIDTH as usize];
            data[0] = 0x40; // Co = 0, D/C# = 1
            data[1..].copy_from_slice(&self.buffer[start..end]);

            self.i2c.write(self.address, &data)?;
        }

        Ok(())
    }
}
🧪 flush() 実装後の動作確認
書き込み前に画面クリア（全消灯）してみて：
display.clear(BinaryColor::Off).unwrap();
display.flush().unwrap();
arduino_hal::delay_ms(1000);
その後にテキスト表示
Text::new("Hello!", Point::new(16, 16), text_style)
    .draw(&mut display)
    .unwrap();
display.flush().unwrap();
🔒 buffer が private で触れない件
ライブラリ側で pub 指定してるんですが

それは Sh1107gBuilder や DrawTarget 実装などでのみ使われており、外部からアクセスできるようにするには：

pub buffer: [u8; BUFFER_SIZE],
と書く必要があります。

ただし、本来 buffer に直接アクセスせず flush() を使ってください。

✅ 結論
今光らない最大の理由は flush() が未実装 または buffer → OLED 転送処理が欠けている ことです。

上記の flush() 実装を組み込めば、表示が動作する可能性が非常に高いです。

必要なら init() の I2C コマンド群（初期化シーケンス）も確認します。試してみてください。
