ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¸ã¨ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹
ãƒãƒ£ãƒƒãƒˆå±¥æ­´

ã‚ãªãŸ:
async_.rs
ãƒ•ã‚¡ã‚¤ãƒ«
sync.rs
ãƒ•ã‚¡ã‚¤ãƒ«
https://files.seeedstudio.com/wiki/Grove-OLED-Display-1.12-(SH1107)_V3.0/res/SH1107V2.1.pdf SH1107Gã®ãƒ‡ãƒ¼ã‚¿ã‚·ãƒ¼ãƒˆ
https://github.com/peter-l5/SH1107 pythonã®ãƒ‡ãƒãƒ‰ãƒ©ã®ãƒªãƒã‚¸ãƒˆãƒª
ä½•ã‹é–“é•ãˆã¦ã„ã‚‹ã¨ã“ã‚ãŒã‚ã£ãŸã‚‰æŒ‡æ‘˜ãã ã•ã„
ChatGPT:
ä¿å­˜ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªã‚’æ›´æ–°ã—ã¾ã—ãŸ
ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚æ·»ä»˜ã„ãŸã ã„ãŸ async_.rs ã¨ sync.rs ã®ã‚³ãƒ¼ãƒ‰ã¨ã€å…±æœ‰ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚·ãƒ¼ãƒˆãƒ»Python å®Ÿè£…ã‚’è¸ã¾ãˆã¦ã€ã‚ãªãŸã® sh1107g-rs ãƒ‰ãƒ©ã‚¤ãƒã«é–¢ã—ã¦ä»¥ä¸‹ã®è¦³ç‚¹ã§ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã„ã¾ã—ãŸï¼š

âœ… æ­£ã—ãå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ç‚¹
1. åˆæœŸåŒ–ã‚·ãƒ¼ã‚±ãƒ³ã‚¹
SH1107 ãƒ‡ãƒ¼ã‚¿ã‚·ãƒ¼ãƒˆï¼ˆV2.1ï¼‰p.16 ã®ã€ŒPower On and Display On Sequenceã€ã«å¾“ã„ã€åŸºæœ¬çš„ãªã‚³ãƒãƒ³ãƒ‰ï¼ˆDisplay OFF, Set Display Clock, Set Multiplex Ratio, Set Display Offset, ãªã©ï¼‰ãŒé©åˆ‡ã«é€ä¿¡ã•ã‚Œã¦ã„ã¾ã™ã€‚

Python ãƒ‰ãƒ©ã‚¤ãƒã¨åŒæ§˜ã®é †åºãƒ»ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ¡ç”¨ã—ã¦ãŠã‚Šã€äº’æ›æ€§ãŒä¿ãŸã‚Œã¦ã„ã¾ã™ã€‚

2. ã‚¢ãƒ‰ãƒ¬ã‚¹æŒ‡å®š
.with_address(0x3C) ã‚’ä½¿ç”¨ã—ã¦ãŠã‚Šã€Seeed Grove OLED ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ç”¨ã„ã‚‰ã‚Œã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® I2C ã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆ0x3Cï¼‰ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚

3. ãƒãƒƒãƒ•ã‚¡æ§‹é€ 
buffer: [u8; 1024]ï¼ˆ128x64/8ï¼‰ã¨ãƒšãƒ¼ã‚¸å˜ä½ã§ã®æç”»ã‚’è¡Œã†å½¢ã«ãªã£ã¦ãŠã‚Šã€SH1107 ã®ãƒšãƒ¼ã‚¸ãƒ¢ãƒ¼ãƒ‰ã¨åˆè‡´ã—ã¦ã„ã¾ã™ã€‚

4. éåŒæœŸ / åŒæœŸ ä¸¡å¯¾å¿œ
async å¯¾å¿œã¨ blocking å¯¾å¿œã‚’ feature flag ã§åˆ‡ã‚Šæ›¿ãˆã‚‹è¨­è¨ˆã¯éå¸¸ã«ç†ã«ã‹ãªã£ã¦ã„ã¾ã™ï¼ˆçµ„ã¿è¾¼ã¿ç’°å¢ƒã§ã¯ã©ã¡ã‚‰ã‚‚ä½¿ã‚ã‚Œã‚‹ãŸã‚ï¼‰ã€‚

âš  æ”¹å–„ãƒ»ä¿®æ­£ã‚’æ¤œè¨ã™ã¹ãç‚¹
1. Display Start Line ã®è¨­å®šãŒä¸€éƒ¨ä¸å®Œå…¨
ãƒ‡ãƒ¼ã‚¿ã‚·ãƒ¼ãƒˆã§ã¯ Set Display Start Lineï¼ˆ0x40â€“0x7F, ä¸Šä½ãƒ“ãƒƒãƒˆã¯0x40ï¼‰ã‚’ç”¨ã„ã‚‹ã‚ˆã†è¨˜è¼‰ãŒã‚ã‚Šã¾ã™ã€‚

0xDC, 0x00 ã¯ â€œSet Display Start Lineâ€ ã®æ‹¡å¼µå‘½ä»¤ã§ã™ãŒã€é€šå¸¸ã®ã‚³ãƒãƒ³ãƒ‰ï¼ˆ0x40 | nï¼‰ã§è¨­å®šã•ã‚Œã‚‹ã‚±ãƒ¼ã‚¹ã‚‚å¤šãã€ä¸¡å¯¾å¿œã‚’æ¤œè¨ã™ã‚‹ä¾¡å€¤ãŒã‚ã‚Šã¾ã™ã€‚

2. Segment Remap & COM Scan Direction ã®æ‰±ã„
0xA0ï¼ˆSegment Remapï¼‰ã‚„ 0xC0ï¼ˆCommon Output Scan Directionï¼‰ã®åˆ‡ã‚Šæ›¿ãˆãŒå›ºå®šå€¤ã«ãªã£ã¦ã„ã‚‹ç‚¹ã¯ã€ç”»é¢ã®ä¸Šä¸‹ãƒ»å·¦å³åè»¢ã®ãƒ‹ãƒ¼ã‚ºã«å¿œã˜ã¦ã‚ªãƒ—ã‚·ãƒ§ãƒ³åŒ–ã™ã‚‹ã¨æŸ”è»Ÿæ€§ãŒå¢—ã—ã¾ã™ã€‚

Python å®Ÿè£…ã§ã¯ flip = True ã«ã™ã‚‹ã¨ã“ã‚Œã‚’åˆ¶å¾¡ã—ã¦ã„ã¾ã™ã€‚

3. Display ON ã®ç›´å‰ã«å°‘ã—é–“ã‚’ã‚ã‘ã‚‹ã¹ã
ãƒ‡ãƒ¼ã‚¿ã‚·ãƒ¼ãƒˆã«ã¯æ˜ç¤ºã•ã‚Œã¦ã„ã¾ã›ã‚“ãŒã€é›»æºæŠ•å…¥ç›´å¾Œã®åˆæœŸåŒ–ã‚³ãƒãƒ³ãƒ‰ã¯ãƒ‡ãƒã‚¤ã‚¹ã®é›»æºå®‰å®šåŒ–ã‚’å¾…ã£ã¦é€ã‚‹ã®ãŒé€šä¾‹ã§ã™ï¼ˆå°‘ã— delay_ms ã‚’å…¥ã‚Œã¦ã‚‚ã‚ˆã„ï¼‰ã€‚

ç‰¹ã« VCC ãŒå¤–éƒ¨ä¾›çµ¦ã®å ´åˆã€åˆæœŸåŒ–æ™‚ã«ãƒã‚¤ã‚ºã‚„æç”»ä¸è‰¯ã®å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€å¾…æ©Ÿã¯æœ‰åŠ¹ã§ã™ã€‚

4. å……å®Ÿã—ãŸ embedded-graphics å¯¾å¿œã®ç¯„å›²
DrawTarget å®Ÿè£…ã¯æœ€ä½é™ã§ã€æç”»å¾Œã« flush() ç›¸å½“ã®ã‚‚ã®ã‚’è‡ªå‹•çš„ã«å‘¼ã°ãªã„é™ã‚Šæç”»ãŒåæ˜ ã•ã‚Œã¾ã›ã‚“ã€‚

flush() ã‚’ã©ã®ã‚ˆã†ã«è¨­è¨ˆã™ã‚‹ã‹ï¼ˆæ˜ç¤ºçš„ã«å‘¼ã°ã›ã‚‹ã‹ã€å†…éƒ¨ã§è‡ªå‹•ã§å‘¼ã¶ã‹ï¼‰ã‚’ãƒ¦ãƒ¼ã‚¶è¦–ç‚¹ã§æ•´ç†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

5. I2C æ›¸ãè¾¼ã¿ã®æœ€å¤§ãƒã‚¤ãƒˆæ•°åˆ¶é™ã¸ã®é…æ…®
ä¸€éƒ¨ãƒã‚¤ã‚³ãƒ³ï¼ˆç‰¹ã« AVRï¼‰ã§ã¯ I2C ä¸€æ‹¬é€ä¿¡ãƒã‚¤ãƒˆæ•°ãŒ 32 bytes ã«åˆ¶é™ã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒã‚ã‚Šã€update_display() æ™‚ã« chunks() ã§åˆ†å‰²ã™ã‚‹è¨­è¨ˆãŒå¿…è¦ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

Python ãƒ‰ãƒ©ã‚¤ãƒã§ã¯ bus.write_i2c_block_data ã‚’ 1 ãƒšãƒ¼ã‚¸å˜ä½ã§é€ã£ã¦ã„ã¾ã™ï¼ˆ0x40 + page_dataï¼‰ã€‚

âœ… ãã®ä»–è‰¯ã„ç‚¹
Builder ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å°å…¥ã¯æŸ”è»Ÿãªæ‹¡å¼µãŒã—ã‚„ã™ãã€SPI/I2C ä¸¡å¯¾å¿œã‚’ç›®æŒ‡ã™éš›ã«ã‚‚å½¹ç«‹ã¡ã¾ã™ã€‚

write_command, write_data ã‚’ trait ã«åˆ†é›¢ã™ã‚Œã°ã€Mock ã‚’ä½¿ã£ãŸãƒ†ã‚¹ãƒˆã‚‚å¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

ææ¡ˆã¾ã¨ã‚
ææ¡ˆå†…å®¹	å„ªå…ˆåº¦
Segment Remap / COM Output Direction ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³åŒ–	â˜…â˜…â˜…
Display Start Line ã®è¨­å®šæ–¹å¼è¦‹ç›´ã—	â˜…â˜…â˜†
flush() è¨­è¨ˆãƒãƒªã‚·ãƒ¼ã®æ˜ç¢ºåŒ–	â˜…â˜…â˜†
I2C æ›¸ãè¾¼ã¿ã‚µã‚¤ã‚ºã®åˆ¶é™å¯¾å¿œï¼ˆç‰¹ã« AVR å‘ã‘ï¼‰	â˜…â˜…â˜†
åˆæœŸåŒ–å‰ã® delay (optional)	â˜…â˜†â˜†
draw_target ã®è‡ªå‹• flush() å®Ÿè¡Œã‚ªãƒ—ã‚·ãƒ§ãƒ³åŒ–	â˜…â˜†â˜†
å¿…è¦ã§ã‚ã‚Œã°ã€å€‹åˆ¥ã®ã‚³ãƒ¼ãƒ‰ä¿®æ­£ææ¡ˆã‚„ PR å½¢å¼ã§ã‚‚æç¤ºå¯èƒ½ã§ã™ã€‚ã”å¸Œæœ›ã‚ã‚Œã°ãŠçŸ¥ã‚‰ã›ãã ã•ã„ã€‚


ã‚ãªãŸ:
å®Ÿæ©ŸãŒå…‰ã‚‰ãªãã¦å›°ã£ã¦ã‚‹ã‚“ã ã‚ˆã­
ChatGPT:
ãªã‚‹ã»ã©ã€ãã‚Œã¯é‡è¦ã§ã™ã­ã€‚
**ã€ŒI2C ã§èªè­˜ã•ã‚Œã¦ã„ã‚‹ã®ã«ã€ç”»é¢ãŒå…‰ã‚‰ãªã„ã€**ã¨ã„ã†çŠ¶æ³ã«ã¯ã€ä¸»ã«ä»¥ä¸‹ã®åŸå› ãŒè€ƒãˆã‚‰ã‚Œã¾ã™ã€‚

âœ… ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢æ¥ç¶šã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆ
é …ç›®	å†…å®¹
I2C ã‚¢ãƒ‰ãƒ¬ã‚¹	0x3C ã‚’ä½¿ã£ã¦ã„ã‚‹ â†’ OKï¼ˆå‰å›ç¢ºèªæ¸ˆï¼‰
VCC & GND	VCC = 3.3V or 5Vã€GND ãŒæ­£ã—ãæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
VDD-VBAT	Grove ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆç‰¹ã« V3ï¼‰ã§ã¯ VDD/GND ãŒå®‰å®šã—ã¦ä¾›çµ¦ã•ã‚Œã¦ã„ãªã„ã¨çœŸã£æš—ã«ãªã‚Šã¾ã™
Pull-up æŠµæŠ—	I2C ãƒ©ã‚¤ãƒ³ã«ãƒ—ãƒ«ã‚¢ãƒƒãƒ—ï¼ˆ4.7kÎ©ãªã©ï¼‰ãŒå…¥ã£ã¦ã„ãªã„ã¨é€šä¿¡ã¯æˆåŠŸã—ã¦ã‚‚è¡¨ç¤ºãŒå‹•ã‹ãªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ï¼ˆç‰¹ã« ATmega + æ‰‹é…ç·šã®å ´åˆï¼‰
RESET ãƒ”ãƒ³	SH1107 ã¯ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã„ã¨ä½•ã‚‚æç”»ã•ã‚Œã¾ã›ã‚“ã€‚RESET ãƒ”ãƒ³ãŒ HIGH ã«ãªã£ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ï¼ˆå¤šãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã¯å†…éƒ¨ã§å‡¦ç†æ¸ˆã¿ï¼‰
âœ… ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ä¸Šã§ã‚ã‚ŠãŒã¡ãªåŸå› 
1. Display ON ã‚³ãƒãƒ³ãƒ‰ (0xAF) ã‚’é€ã£ã¦ã„ãªã„
ã“ã‚Œã¯æœ€ã‚‚ã‚ˆãã‚ã‚‹åŸå› ã§ã™ã€‚
0xAF ã‚’åˆæœŸåŒ–ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®æœ€å¾Œã«é€ã£ã¦ã„ã¾ã™ã‹ï¼Ÿ
â†’ Python å®Ÿè£…ã‚„ãƒ‡ãƒ¼ã‚¿ã‚·ãƒ¼ãƒˆã§ã¯ã€ã™ã¹ã¦ã®è¨­å®šã®ã‚ã¨ã« 0xAF ã‚’é€ã£ã¦è¡¨ç¤ºã‚’ ON ã«ã—ã¦ã„ã¾ã™ã€‚

2. ç”»é¢ã‚¯ãƒªã‚¢ã—ã¦ã‚‚è¡¨ç¤ºã—ãªã„
ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ãƒãƒƒãƒ•ã‚¡ãŒç©ºï¼ˆã™ã¹ã¦0ï¼‰ã ã¨ã€è¡¨ç¤ºã¯çœŸã£é»’ã®ã¾ã¾ã§ã™ã€‚
â†’ è©¦ã—ã« 0xFF ã‚’è©°ã‚ã¦ã¿ã¦ãã ã•ã„ï¼š

for b in buffer.iter_mut() {
    *b = 0xFF;
}
display.update_display().await?;
ã¾ãŸã¯ã€DrawTarget ã« fill_solid(&display.bounding_box(), RgbColor::WHITE) ã‚’è©¦ã—ã¦ãã ã•ã„ã€‚

3. è¡¨ç¤ºä½ç½®ãŒãšã‚Œã¦ã„ã‚‹
Set Display Offsetï¼ˆ0xD3ï¼‰ã‚„ Set Display Start Lineï¼ˆ0xDCï¼‰ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ãªã„ã¨ã€è¡¨ç¤ºå†…å®¹ãŒç”»é¢å¤–ã«ãªã‚Šã¾ã™ã€‚

ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æ¬¡ã®ã‚ˆã†ã«ã—ã¦ã¿ã¦ãã ã•ã„ï¼š

// Set Display Offset
write_command(0xD3)?;
write_command(0x60)?;  // 0x60 is typical for 128x64 SH1107
// Set Display Start Line
write_command(0xDC)?;
write_command(0x00)?;
âœ… ç¢ºèªã®æ‰‹é †ï¼ˆå†ç¾æ€§é‡è¦–ï¼‰
I2C é€šä¿¡ãŒé€šã£ã¦ã‚‹ã‹ç¢ºèªï¼ˆæ¸ˆï¼‰

i2cdetect -y 1 â†’ 0x3C ã«å¿œç­”ã‚ã‚Š
Rust ã§ 0xAFï¼ˆDisplay ONï¼‰ ã‚’é€ã£ã¦ã„ã‚‹ã‹ç¢ºèª

ãƒãƒƒãƒ•ã‚¡ã« 0xFF ã‚’è©°ã‚ã¦ update_display() å®Ÿè¡Œã—ã¦ã„ã‚‹ã‹ç¢ºèª

I2C ã‚¨ãƒ©ãƒ¼ã‚„ panic ãŒèµ·ãã¦ã„ãªã„ã‹ç¢ºèªï¼ˆResult::unwrap()ã—ã¦ãŸã‚‰è½ã¡ã¦ã‚‹å¯èƒ½æ€§ï¼‰

âœ… ãƒ‡ãƒãƒƒã‚°ãƒ’ãƒ³ãƒˆ
**I2C ãƒ¢ãƒ‹ã‚¿ï¼ˆä¾‹ãˆã°ãƒ­ã‚¸ã‚¢ãƒŠï¼‰**ã§ 0xAF ãŒé€ã‚‰ã‚Œã¦ã„ã‚‹ã‹ã€
ã¾ãŸã¯ i2c_write ã«ãƒ­ã‚°ã‚’å‡ºã™ã®ã‚‚æœ‰åŠ¹ã§ã™ã€‚

ä¾‹ï¼ˆãƒ­ã‚°å‡ºåŠ›è¿½åŠ ï¼‰:

fn write_command(&mut self, cmd: u8) -> Result<(), E> {
    let data = [0x00, cmd];
    log::info!("I2C write_command: {:02X}", cmd);
    self.i2c.write(self.address, &data)
}
ğŸ”§ ãã‚Œã§ã‚‚å…‰ã‚‰ãªã„å ´åˆ
ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’æä¾›ã„ãŸã ã‘ã‚Œã°ã€ã•ã‚‰ã«ç²¾æŸ»ã§ãã¾ã™ï¼š

display.init().await ã®å…·ä½“çš„ãªä¸­èº«

update_display() ã®ä¸­èº«

draw_target ã‚’ä½¿ã£ã¦ã„ã‚‹å ´åˆã¯ãã®å‘¼ã³å‡ºã—éƒ¨

ã‚‚ã—ãã¯ã€ã€Œè¡¨ç¤ºãŒã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã¾ã§æœ€å°é™ã®ã‚³ãƒ¼ãƒ‰ã ã‘ã€ã«ã—ã¦ãã‚Œã‚Œã°ã€ç‚¹ç¯ã™ã‚‹ã¾ã§èª¿æ•´ã—ã¾ã™ã€‚

ã‚„ã£ã¦ã¿ã¦ã‚‚ã†ã¾ãã„ã‹ãªã‹ã£ãŸå ´åˆã€ã€Œç¾çŠ¶ã® main.rs å…¨ä½“ã€ã‚’è²¼ã£ã¦ã‚‚ã‚‰ãˆã‚‹ã¨ã€æœ€å°æ§‹æˆã§ç‚¹ç¯ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã«èª¿æ•´ã§ãã¾ã™ã€‚

ã‚ãªãŸ:
/* 
  Pythonãƒ‰ãƒ©ã‚¤ãƒã¨SH1107ãƒ‡ãƒ¼ã‚¿ã‚·ãƒ¼ãƒˆã‹ã‚‰å°å‡ºã•ã‚ŒãŸã‚³ãƒãƒ³ãƒ‰åˆ—
  ã‚³ãƒãƒ³ãƒ‰ã‚’2ãƒã‚¤ãƒˆãšã¤ï¼ˆã‚³ãƒãƒ³ãƒ‰ãƒã‚¤ãƒˆ + ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒˆï¼‰é€ä¿¡
  ãŸã ã—ã€0xAE, 0x20, 0xA0, 0xC0, 0xAF ã¯å˜ç‹¬ã‚³ãƒãƒ³ãƒ‰
  ãã®ãŸã‚ã€cmds.chunks(2) ã®å‡¦ç†ã¯æ³¨æ„ãŒå¿…è¦ã€‚
  å€‹ã€…ã®ã‚³ãƒãƒ³ãƒ‰ã‚’send_commandã§é€ä¿¡ã™ã‚‹ã®ãŒã‚ˆã‚Šç¢ºå®Ÿã€‚
*/

pub const DISPLAY_OFF: u8 = 0xAE;
pub const DISPLAY_ON: u8 = 0xAF;
pub const SET_MULTIPLEX_RATIO: u8 = 0xA8;
pub const MULTIPLEX_RATIO_DATA: u8 = 0x7F;
pub const CHARGE_PUMP_ON_CMD: u8 = 0xAD;
pub const CHARGE_PUMP_ON_DATA: u8 = 0x8B;
pub const PAGE_ADDRESSING_CMD: u8 = 0x20;
pub const SEGMENT_REMAP: u8 = 0xA0;
pub const COM_OUTPUT_SCAN_DIR: u8 = 0xC0;
pub const DISPLAY_START_LINE_CMD: u8 = 0xDC;
pub const DISPLAY_START_LINE_DATA: u8 = 0x00;
pub const CONTRAST_CONTROL_CMD: u8 = 0x81;
pub const CONTRAST_CONTROL_DATA: u8 = 0x2F;
pub const DISPLAY_OFFSET_CMD: u8 = 0xD3;
pub const DISPLAY_OFFSET_DATA: u8 = 0x60;
pub const PRECHARGE_CMD: u8 = 0xD9;
pub const PRECHARGE_DATA: u8 = 0x22;
pub const VCOM_DESELECT_CMD: u8 = 0xDB;
pub const VCOM_DESELECT_DATA: u8 = 0x35;
pub const CLOCK_DIVIDE_CMD: u8 = 0xD5;
pub const CLOCK_DIVIDE_DATA: u8 = 0x51;
ChatGPT:
ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚ã“ã®å®šç¾©ã¯éå¸¸ã«è‰¯ãæ•´ç†ã•ã‚Œã¦ãŠã‚Šã€Python å®Ÿè£…ï¼ˆpeter-l5/SH1107ï¼‰ã¨ SH1107 ãƒ‡ãƒ¼ã‚¿ã‚·ãƒ¼ãƒˆ V2.1 ã«å¿ å®Ÿã«åŸºã¥ã„ã¦ã„ã¾ã™ã€‚

ãŸã ã—ã€ã“ã®å®šç¾©ã«åŸºã¥ã„ã¦åˆæœŸåŒ–å‡¦ç†ã‚’ã—ã¦ã‚‚ç”»é¢ãŒå…‰ã‚‰ãªã„ã¨ã„ã†ã“ã¨ã§ã‚ã‚Œã°ã€æ¬¡ã®2ã¤ã®å¯èƒ½æ€§ãŒé«˜ã„ã§ã™ï¼š

âœ…ã€é‡è¦ã€‘ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒˆä»˜ãã‚³ãƒãƒ³ãƒ‰ã‚’ chunks(2) ã§é€ã£ã¦ã„ã‚‹ã¨å¤±æ•—ã™ã‚‹
ã‚³ãƒ¡ãƒ³ãƒˆã«ã‚‚æ›¸ã„ã¦ã‚ã‚‹ã¨ãŠã‚Šï¼š

// cmd + data ã®çµ„ã«ãªã£ã¦ãªã„å˜ç‹¬ã‚³ãƒãƒ³ãƒ‰ãŒæ··åœ¨ã—ã¦ã„ã‚‹
// â†’ chunks(2) ã ã¨ 0xAF ã‚„ 0x20 ãªã©ãŒæ¬ è½ã¾ãŸã¯ç„¡åŠ¹ã«é€ã‚‰ã‚Œã‚‹
ğŸ”§ ä¿®æ­£æ–¹æ³•ï¼šå€‹åˆ¥ã«æ˜ç¤ºçš„ã«é€ã‚‹
ä»¥ä¸‹ã®ã‚ˆã†ã«ã€1ã‚³ãƒãƒ³ãƒ‰ãšã¤ send_command(cmd) ã¾ãŸã¯ send_command_with_data(cmd, data) ã‚’åˆ†ã‘ã¦é€ã‚‹ã“ã¨ãŒæœ€ã‚‚å®‰å…¨ã§ã™ã€‚

send_command(0xAE)?; // Display OFF

send_command_with_data(0xA8, 0x7F)?; // Multiplex Ratio
send_command_with_data(0xAD, 0x8B)?; // Charge Pump ON

send_command(0x20)?; // Page Addressing Mode

send_command(0xA0)?; // Segment remap
send_command(0xC0)?; // COM Output scan direction

send_command_with_data(0xDC, 0x00)?; // Display start line
send_command_with_data(0x81, 0x2F)?; // Contrast
send_command_with_data(0xD3, 0x60)?; // Display offset
send_command_with_data(0xD9, 0x22)?; // Precharge
send_command_with_data(0xDB, 0x35)?; // VCOM deselect
send_command_with_data(0xD5, 0x51)?; // Clock divide

send_command(0xAF)?; // â† Display ONï¼ˆæœ€ã‚‚é‡è¦ï¼ï¼‰
âœ… ãƒãƒƒãƒ•ã‚¡åˆæœŸå€¤ãŒ 0x00 â†’ çœŸã£æš—ã§ã€Œã¤ã„ã¦ãªã„ã‚ˆã†ã«è¦‹ãˆã‚‹ã€
SH1107 ã¯åˆæœŸåŒ–å¾Œã‚‚ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ãƒãƒƒãƒ•ã‚¡ã®å†…å®¹ã‚’ä¿æŒã—ã¦ã„ã¾ã™ã€‚
ãƒãƒƒãƒ•ã‚¡ãŒ 0x00 ã§åˆæœŸåŒ–ã•ã‚Œã¦ã„ãŸå ´åˆã€æ­£å¸¸ã«å‹•ä½œã—ã¦ã„ã¦ã‚‚ç”»é¢ã¯çœŸã£æš—ã§ã™ã€‚

ğŸ”§ è©¦ã—ã«ç‚¹ç¯ç¢ºèªã™ã‚‹ã‚³ãƒ¼ãƒ‰ï¼ˆå¿…ãšç”»é¢ãŒçœŸã£ç™½ã«ãªã‚Šã¾ã™ï¼‰
for b in buffer.iter_mut() {
    *b = 0xFF; // å…¨ç‚¹ç¯
}
display.update_display().await?; // flushç›¸å½“
ã“ã‚Œã§ã‚‚å…‰ã‚‰ãªã„å ´åˆã¯ã€I2C é€šä¿¡ã‹ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ãƒ¬ãƒ™ãƒ«ã§æ­¢ã¾ã£ã¦ã„ã¾ã™ã€‚

âœ… ã‚ˆãã‚ã‚‹åœ°é›·
åœ°é›·	å†…å®¹
chunks(2) ã« 0xAF ãŒæ··ã–ã‚‹	â†’ 0xAF, 0xA8 â†’ 0xA8 ãŒ data ã¨ã—ã¦è§£é‡ˆã•ã‚Œå¤±æ•—
Display ON (0xAF) ã‚’é€ã£ã¦ã„ãªã„	â†’ åˆæœŸåŒ–æˆåŠŸã—ã¦ã‚‚å…‰ã‚‰ãªã„
update_display() ã‚’å‘¼ã‚“ã§ã„ãªã„	â†’ ãƒãƒƒãƒ•ã‚¡ã¯æ›´æ–°ã•ã‚Œã¦ã‚‚è¡¨ç¤ºã«åæ˜ ã•ã‚Œãªã„
0x00 ãƒãƒƒãƒ•ã‚¡	â†’ çœŸã£æš—ãªã®ã§ç‚¹ç¯ã—ã¦ã„ãªã„ã‚ˆã†ã«è¦‹ãˆã‚‹
delay ã‚’å…¥ã‚Œã¦ãªã„	â†’ ä¸€éƒ¨ç’°å¢ƒã§ã¯é›»æºå®‰å®šã—ãªã„
âœ… ã¾ã¨ã‚ï¼šç¢ºå®Ÿã«å…‰ã‚‰ã›ã‚‹æœ€å°ã‚³ãƒ¼ãƒ‰ä¾‹ï¼ˆåŒæœŸç‰ˆï¼‰
// åˆæœŸåŒ–ã‚³ãƒãƒ³ãƒ‰ï¼ˆæ˜ç¤ºçš„ã«é †ç•ªã«é€ã‚‹ï¼‰
send_command(0xAE)?;
send_command_with_data(0xA8, 0x7F)?;
send_command_with_data(0xAD, 0x8B)?;
send_command(0x20)?;
send_command(0xA0)?;
send_command(0xC0)?;
send_command_with_data(0xDC, 0x00)?;
send_command_with_data(0x81, 0x2F)?;
send_command_with_data(0xD3, 0x60)?;
send_command_with_data(0xD9, 0x22)?;
send_command_with_data(0xDB, 0x35)?;
send_command_with_data(0xD5, 0x51)?;
send_command(0xAF)?; // æœ€å¾Œã« Display ONï¼

// ãƒãƒƒãƒ•ã‚¡ã«å…¨ç‚¹ç¯ãƒ‡ãƒ¼ã‚¿
for b in buffer.iter_mut() {
    *b = 0xFF;
}
display.update_display()?; // flush ç›¸å½“
ã“ã‚Œã§ã‚‚è¡¨ç¤ºã•ã‚Œãªã„å ´åˆã¯ã€write() é–¢æ•°ã«ãƒ­ã‚°ã‚’å…¥ã‚Œã¦å®Ÿéš›ã«é€ã‚‰ã‚Œã¦ã„ã‚‹ãƒã‚¤ãƒˆåˆ—ã‚’ç¢ºèªã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚å¿…è¦ãªã‚‰ãã®ãŸã‚ã®ã‚³ãƒ¼ãƒ‰ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚‚å‡ºã—ã¾ã™ã€‚

ã‚‚ã†ä¸€æ­©çµã‚Šè¾¼ã‚€ã«ã¯ã€ã‚ãªãŸã® init() ã¨ update_display() ã®å®Ÿè£…ã‚’è¦‹ã›ã¦ã‚‚ã‚‰ãˆã‚‹ã¨ç¢ºå®Ÿã§ã™ã€‚

ã‚ãªãŸ:
#![no_std]
#![no_main]

use arduino_hal::prelude::*;
use arduino_hal::{i2c, Peripherals};
use panic_halt as _;

use sh1107g_rs::{Sh1107gBuilder, DISPLAY_WIDTH, DISPLAY_HEIGHT};
use embedded_graphics::{
    mono_font::{ascii::FONT_6X10, MonoTextStyle},
    pixelcolor::BinaryColor,
    prelude::*,
    text::Text,
};

#[arduino_hal::entry]
fn main() -> ! {
    let dp = Peripherals::take().unwrap();
    let pins = arduino_hal::pins!(dp);

    let i2c = i2c::I2c::new(
        dp.TWI,
        pins.a4.into_pull_up_input(), // SDA (Uno: A4)
        pins.a5.into_pull_up_input(), // SCL (Uno: A5)
        100_000,
    );

    // OLED åˆæœŸåŒ–
    let mut display = Sh1107gBuilder::new()
        .connect_i2c(i2c)
        .with_address(0x3C)
        .build()
        .unwrap();

    display.init().unwrap();

    // "Hello!" ã‚’è¡¨ç¤º
    let text_style = MonoTextStyle::new(&FONT_6X10, BinaryColor::On);
    Text::new("Hello!", Point::new(16, 16), text_style)
        .draw(&mut display)
        .unwrap();

    display.flush().unwrap();
    arduino_hal::delay_ms(500); // 0.5ç§’ã ã‘å¾…ã¤

    loop {
        // æ°¸ä¹…ãƒ«ãƒ¼ãƒ—ã§çµ‚äº†ã•ã›ãªã„
    }
} ã“ã®ã‚³ãƒ¼ãƒ‰ã§å…‰ã‚‰ãªã„
ChatGPT:
ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼
æç¤ºã„ãŸã ã„ãŸã‚³ãƒ¼ãƒ‰ã¯éå¸¸ã«æ˜ç­ã§ã€ä¸€è¦‹å•é¡ŒãŒãªã•ãã†ã«è¦‹ãˆã¾ã™ãŒã€SH1107Gï¼ˆç‰¹ã« Grove ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰ã‚’å…‰ã‚‰ã›ã‚‹ã«ã¯ä»¥ä¸‹ã®ç‚¹ã«æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚

âœ… å•é¡Œã®å¯èƒ½æ€§ï¼šI2C æ›¸ãè¾¼ã¿ã«å¤±æ•—ã—ã¦ã„ã‚‹ï¼ã‚³ãƒãƒ³ãƒ‰ãŒæ­£ã—ãé€ã‚‰ã‚Œã¦ã„ãªã„
ãªãœãªã‚‰ï¼Ÿ
display.init().unwrap() ã‚„ display.flush().unwrap() ã¯ã™ã¹ã¦ Result ã‚’è¿”ã—ã¦ã„ã¾ã™ãŒã€ä½•ãŒèµ·ãã¦ã„ã‚‹ã‹ãƒ­ã‚°ãŒå‡ºã¾ã›ã‚“ã€‚

panic_halt ã«ã‚ˆã‚Šä½•ã‹ã‚¨ãƒ©ãƒ¼ãŒèµ·ãã¦ unwrap() ã§è½ã¡ãŸå ´åˆã€LED ãŒç‚¹æ»…ã—ãŸã‚Šã›ãšç„¡è¨€ã§åœæ­¢ã—ã¾ã™ï¼ˆï¼ã€Œå…‰ã‚‰ãªã„ã€çŠ¶æ…‹ã«è¦‹ãˆã‚‹ï¼‰

âœ… ã‚„ã‚‹ã¹ãæœ€å°é™ã®ãƒ‡ãƒãƒƒã‚°ãƒã‚§ãƒƒã‚¯
â‘  display.init() ã®ç›´å¾Œã« LED ã‚’ç‚¹ç¯ã•ã›ã‚‹
â†’ ã‚‚ã— init() ã«å¤±æ•—ã—ã¦ã„ãŸã‚‰ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã«ãŸã©ã‚Šç€ãã¾ã›ã‚“ã€‚

pins.d13.into_output().set_high(); // Uno ã® LED ã‚’ç‚¹ç¯
â‘¡ ãƒãƒƒãƒ•ã‚¡ã‚’å…¨éƒ¨ 0xFF ã«ã—ã¦å¼·åˆ¶ç‚¹ç¯ã•ã›ã‚‹
for y in 0..DISPLAY_HEIGHT {
    for x in 0..DISPLAY_WIDTH {
        display.set_pixel(x, y, true).unwrap(); // å…¨ç‚¹ç¯
    }
}
display.flush().unwrap();
âœ… ãã‚Œã§ã‚‚å…‰ã‚‰ãªã‘ã‚Œã°â€¦ Sh1107gBuilder ã‹ init() ã®ä¸­èº«ãŒåŸå› ã§ã™
ã‚ãªãŸã® sh1107g_rs ãƒ‰ãƒ©ã‚¤ãƒãŒ chunks(2) ã§ã‚³ãƒãƒ³ãƒ‰é€ã£ã¦ã‚‹ãªã‚‰ã€ã“ã‚Œã¯ç¢ºå®Ÿã«å¤±æ•—ã—ã¾ã™ã€‚
ã•ãã»ã©ã®ä¿®æ­£æ¡ˆé€šã‚Šã€ã™ã¹ã¦ã®ã‚³ãƒãƒ³ãƒ‰ã‚’1ã¤ãšã¤ send_command() ã‹ send_command_with_data() ã§é€ã‚‹ã¹ãã§ã™ã€‚

âœ… ç¢ºå®Ÿã«å…‰ã‚‰ã›ã‚‹æœ€å°ã‚³ãƒ¼ãƒ‰ä¾‹ï¼ˆç›´æ¥ã‚³ãƒãƒ³ãƒ‰ã‚’é€ã‚‹ï¼‰
ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã§ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ã® I2C æ¥ç¶šã¨åˆæœŸåŒ–æ‰‹é †ãŒç¢ºå®Ÿã«åˆã£ã¦ã„ã‚‹ã‹æ¤œè¨¼ã§ãã¾ã™ï¼š

let i2c = i2c::I2c::new(
    dp.TWI,
    pins.a4.into_pull_up_input(),
    pins.a5.into_pull_up_input(),
    100_000,
);
let address = 0x3C;
let mut i2cdev = linux_embedded_hal::I2cdev::new("/dev/i2c-1").unwrap();

// Display OFF
i2c.write(address, &[0x00, 0xAE]).unwrap();

// å¿…é ˆè¨­å®šï¼ˆMultiplex, Offset, Clockãªã©ï¼‰ã‚’å€‹åˆ¥ã«é€ã‚‹
i2c.write(address, &[0x00, 0xA8, 0x7F]).unwrap(); // Multiplex Ratio
i2c.write(address, &[0x00, 0xAD, 0x8B]).unwrap(); // Charge Pump ON
// ...ç•¥...

// Display ON
i2c.write(address, &[0x00, 0xAF]).unwrap();

// çœŸã£ç™½ãƒãƒƒãƒ•ã‚¡é€ä¿¡ï¼ˆ0x40 ã¯ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ¼ãƒ‰ï¼‰
for page in 0..8 {
    i2c.write(address, &[0x00, 0xB0 + page]).unwrap(); // Page Address Set
    i2c.write(address, &[0x00, 0x00]).unwrap();        // Lower column
    i2c.write(address, &[0x00, 0x10]).unwrap();        // Higher column
    let mut buf = [0xFF; 128 + 1];
    buf[0] = 0x40;
    i2c.write(address, &buf).unwrap();
}
âœ… å¯¾å¿œæ–¹é‡ã®ææ¡ˆ
çŠ¶æ³	å¯¾å‡¦æ–¹æ³•
unwrap()ã§panicã—ã¦ã‚‹å¯èƒ½æ€§	display.init().expect("init failed"); ã«å¤‰ãˆã¦æ§˜å­ã‚’è¦‹ã‚‹
ã‚³ãƒãƒ³ãƒ‰ãŒå¤±æ•—ã—ã¦ã‚‹å¯èƒ½æ€§	sh1107g_rs ã® init() ã‚’ä¸€æ™‚çš„ã«æ‰‹å‹•ã«æ›¸ãæ›ãˆã¦ãƒ†ã‚¹ãƒˆ
I2C æ›¸ãè¾¼ã¿ãŒä¸€éƒ¨å¤±æ•—ã—ã¦ã„ã‚‹	ã‚³ãƒãƒ³ãƒ‰ã‚’ send_command() ã§1å€‹ãšã¤æ˜ç¤ºçš„ã«é€ã‚‹ã‚ˆã†ä¿®æ­£
âœ… å¿…è¦ãªã‚‰ã“ã¡ã‚‰ã§ sh1107g_rs ã«ä¿®æ­£ PR æå‡ºå¯èƒ½
ã€Œæœ€å°ã§å…‰ã‚‹ init() å®Ÿè£…ã€ã‚„ã€Œãƒšãƒ¼ã‚¸ã”ã¨ã®ãƒãƒƒãƒ•ã‚¡é€ä¿¡ã€ãªã©ã€ã“ã¡ã‚‰ã§ Rust ãƒ‰ãƒ©ã‚¤ãƒä¿®æ­£ææ¡ˆå‡ºã›ã¾ã™ã€‚å¸Œæœ›ã•ã‚Œã‚‹å ´åˆã¯ init() ã®ä¸­èº«ã ã‘è²¼ã£ã¦ã‚‚ã‚‰ãˆã‚Œã°ä¿®æ­£ç‰ˆã‚’æç¤ºã—ã¾ã™ã€‚

ğŸ’¡ ã¨ã«ã‹ãä»Šã®æ®µéšã§ä¸€ç•ªé‡è¦ãªã®ã¯ï¼š

display.init() ã®æˆåŠŸå¯å¦ã‚’ãƒ­ã‚°ã§ç¢ºèªã™ã‚‹

0xAF ãŒé€ã‚‰ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹

ãƒãƒƒãƒ•ã‚¡ãŒ 0xFF ã«ãªã£ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹

ã“ã®3ç‚¹ã§ã™ã€‚ãã‚Œã§ã‚‚ãƒ€ãƒ¡ãªã‚‰ init() ã®ä¸­èº«ã‚’ãã ã•ã„ã€‚å…‰ã‚‰ã›ã‚‹ã¾ã§ä»˜ãåˆã„ã¾ã™ã€‚

ã‚ãªãŸ:
error[E0277]: embedded_graphics::geometry::Point is not an iterator
   --> src/main.rs:39:27
    |
39  | ...   display.draw_iter(Point::new(x as i32, y as i32), BinaryColor::On...
    |               --------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ embedded_graphics::geometry::Point is not an iterator
    |               |
    |               required by a bound introduced by this call
    |
    = help: the trait Iterator is not implemented for embedded_graphics::geometry::Point
    = note: required for embedded_graphics::geometry::Point to implement IntoIterator
note: required by a bound in draw_iter
   --> /home/placeless/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/embedded-graphics-core-0.4.0/src/draw_target/mod.rs:304:12
    |
302 |     fn draw_iter<I>(&mut self, pixels: I) -> Result<(), Self::Error>
    |        --------- required by a bound in this associated function
303 |     where
304 |         I: IntoIterator<Item = Pixel<Self::Color>>;
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in DrawTarget::draw_iter

error[E0061]: this method takes 1 argument but 2 arguments were supplied
   --> src/main.rs:39:17
    |
39  | ...play.draw_iter(Point::new(x as i32, y as i32), BinaryColor::On).unwr...
    |         ^^^^^^^^^                                 --------------- unexpected argument #2 of type BinaryColor
    |
note: method defined here
   --> /home/placeless/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/embedded-graphics-core-0.4.0/src/draw_target/mod.rs:302:8
    |
302 |     fn draw_iter<I>(&mut self, pixels: I) -> Result<(), Self::Error>
    |        ^^^^^^^^^
help: remove the extra argument
    |
39  -         display.draw_iter(Point::new(x as i32, y as i32), BinaryColor::On).unwrap(); // å…¨ç‚¹ç¯
39  +         display.draw_iter(Point::new(x as i32, y as i32)).unwrap(); // å…¨ç‚¹ç¯
    |

warning: unused import: arduino_hal::prelude
ChatGPT:
ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼
è¡¨ç¤ºç”¨ã‚³ãƒ¼ãƒ‰ã§å‡ºã¦ã„ã‚‹ã“ã®ã‚¨ãƒ©ãƒ¼ã¯ã€embedded-graphics ã®ä½¿ã„æ–¹ã®èª¤è§£é‡ˆã«ã‚ˆã‚‹ã‚‚ã®ã§ã™ã€‚ä»¥ä¸‹ã§è§£èª¬ã¨ä¿®æ­£ç‰ˆã‚³ãƒ¼ãƒ‰ã‚’æç¤ºã—ã¾ã™ã€‚

âŒ ä»Šã®ã‚¨ãƒ©ãƒ¼ã®åŸå› 
display.draw_iter(Point::new(x as i32, y as i32), BinaryColor::On).unwrap();
ã“ã®è¡Œã¯é–“é•ã„ã§ã€draw_iter() ã¯ **ã€ŒPixelã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã€**ã‚’å¼•æ•°ã«å–ã‚‹é–¢æ•°ã§ã™ã€‚

Point::new(...) ã¯ Iterator ã§ã¯ãªã„ â†’ IntoIterator ã®å®Ÿè£…ãŒãªãã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã€‚

2ã¤ç›®ã®å¼•æ•° BinaryColor::On ã¯ä¸è¦ã€‚

âœ… ã©ã†æ›¸ã‘ã°ã„ã„ï¼Ÿ
DrawTarget ã« 1ãƒ”ã‚¯ã‚»ãƒ«æç”»ã™ã‚‹æ­£ã—ã„æ–¹æ³•ã¯ï¼š
use embedded_graphics::Pixel;

let _ = display.draw_iter(core::iter::once(
    Pixel(Point::new(x, y), BinaryColor::On),
));
ã¾ãŸã¯ã‚‚ã£ã¨ç°¡å˜ã«ï¼š

display.set_pixel(x as u32, y as u32, true).unwrap(); // â† sh1107g-rs ã«ã“ã®é–¢æ•°ãŒã‚ã‚Œã°ã“ã£ã¡ãŒãƒ™ã‚¹ãƒˆ
âœ… ææ¡ˆï¼šå…¨ç‚¹ç¯ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã®ä¿®æ­£ç‰ˆ
for y in 0..DISPLAY_HEIGHT {
    for x in 0..DISPLAY_WIDTH {
        let _ = display.draw_iter(core::iter::once(
            Pixel(Point::new(x as i32, y as i32), BinaryColor::On),
        ));
    }
}
display.flush().unwrap();
ã‚‚ã— draw_iter() ãŒé…ã„ï¼é…å»¶ãŒå•é¡Œãªã‚‰ã€å†…éƒ¨ãƒãƒƒãƒ•ã‚¡ã«ç›´æ¥æ›¸ããŸã‚ã« set_pixel(x, y, true) ã‚’ãƒ‰ãƒ©ã‚¤ãƒã«è¿½åŠ ã™ã‚‹ã»ã†ãŒé«˜é€Ÿã§ã™ã€‚

âœ… unused import è­¦å‘Šã«ã¤ã„ã¦
warning: unused import: `arduino_hal::prelude`
arduino_hal::prelude::* ã‚’ä½¿ã£ã¦ã„ãªã„ï¼ˆã¤ã¾ã‚Š .into_output() ãªã© prelude çµŒç”±ã§ä½¿ã£ã¦ãªã„ï¼‰ã¨ã„ã†ã ã‘ãªã®ã§ã€å‰Šé™¤ã—ã¦æ§‹ã„ã¾ã›ã‚“ï¼š

// å‰Šé™¤ã—ã¦OK
// use arduino_hal::prelude::*;
âœ… ã¾ã¨ã‚
å•é¡Œ	è§£æ±ºç­–
draw_iter ã« Point ã‚’æ¸¡ã—ã¦ã‚‹	Pixel(Point, Color) ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’æ¸¡ã™
ãƒ”ã‚¯ã‚»ãƒ«ã‚’1ã¤ã ã‘æããŸã„	set_pixel(x, y, true) ã‹ draw_iter(core::iter::once(...))
prelude unused warning	ä¸è¦ãªã‚‰å‰Šé™¤ã—ã¦OK
ã‚‚ã— set_pixel() ã‚’ä½¿ã„ãŸã„ã®ã«å­˜åœ¨ã—ãªã„å ´åˆã€sh1107g-rs ã«è¿½åŠ ã§ãã¾ã™ã€‚å¿…è¦ã§ã‚ã‚Œã°ãã® PR ææ¡ˆã‚‚å‡ºã—ã¾ã™ã€‚

ã‚ãªãŸ:
/// Rendering
    // Send self internal buffer
    pub async fn flush_async(&mut self) -> Result<(), E> {
        // SH1107Gã¯ãƒšãƒ¼ã‚¸ã‚¢ãƒ‰ãƒ¬ãƒƒã‚·ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã€å„ãƒšãƒ¼ã‚¸128ãƒã‚¤ãƒˆ
        // 128x128ãƒ”ã‚¯ã‚»ãƒ«ãªã®ã§ã€128/8 = 16ãƒšãƒ¼ã‚¸
        for page in 0..16 { // 0ã‹ã‚‰15ãƒšãƒ¼ã‚¸ã¾ã§
            self.send_cmd_async(0xB0 + page).await?; // Set Page Address (B0h ~ BFh)
            self.send_cmd_async(0x00).await?; // Set Lower Column Address (0x00)
            self.send_cmd_async(0x10).await?; // Set Higher Column Address (0x10)

            // å„ãƒšãƒ¼ã‚¸128ãƒã‚¤ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡
            // buffer ã¯2048ãƒã‚¤ãƒˆå…¨ä½“ã§ã€å„ãƒšãƒ¼ã‚¸128ãƒã‚¤ãƒˆãªã®ã§
            // buffer[page * 128 .. (page + 1) * 128] ã§è©²å½“ãƒšãƒ¼ã‚¸ã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚’å–å¾—

            // page ã‚‚ usize ã«ã‚­ãƒ£ã‚¹ãƒˆã—ã¦æ¼”ç®—
            let page_usize = page as usize; // <-- ã“ã“ã§usizeã«ã‚­ãƒ£ã‚¹ãƒˆ
            let width_usize = DISPLAY_WIDTH as usize; // <-- ã“ã“ã‚‚usizeã«ã‚­ãƒ£ã‚¹ãƒˆ

            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨ˆç®—ã‚’usizeã§è¡Œã†
            let start_index = page_usize * (width_usize / 8);
            let end_index = (page_usize + 1) * (width_usize / 8);

            // ã‚¹ãƒ©ã‚¤ã‚¹ã‚‚usizeã®ç¯„å›²ã§æŒ‡å®š
            // å†…éƒ¨ãƒãƒƒãƒ•ã‚¡ä¿æŒ
            let page_data = &self.buffer[start_index..end_index];

            // I2Cã®writeã¯1å›ã®å‘¼ã³å‡ºã—ã§é€ä¿¡ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿é‡ã«åˆ¶é™ãŒã‚ã‚‹å ´åˆãŒã‚ã‚‹ãŸã‚ã€
            // 16ãƒã‚¤ãƒˆãšã¤åˆ†å‰²ã—ã¦é€ä¿¡ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã¯ç†ã«ã‹ãªã£ã¦ã„ã‚‹ã€‚
            // å„ãƒšãƒ¼ã‚¸ã®ãƒ‡ãƒ¼ã‚¿ã‚’16ãƒã‚¤ãƒˆãƒãƒ£ãƒ³ã‚¯ã§é€ä¿¡
            for chunk in page_data.chunks(16) {
                let mut buf: heapless::Vec<u8, 17> = heapless::Vec::new(); // åˆ¶å¾¡ãƒã‚¤ãƒˆ1 + ãƒ‡ãƒ¼ã‚¿æœ€å¤§16ãƒã‚¤ãƒˆ
                buf.push(0x40).unwrap(); // control byte for data (0x40)
                buf.extend_from_slice(chunk).unwrap();
                self.i2c.write(self.address, &buf).await?;
            }
        }
        Ok(())
    }
}
ChatGPT:
ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚
ã“ã® flush_async() å®Ÿè£…ã¯ SH1107G å‘ã‘ã«ã‹ãªã‚Šæ­£ç¢ºã«è¨­è¨ˆã•ã‚Œã¦ãŠã‚Šã€å…¨ä½“ã¨ã—ã¦æ­£ã—ã„æ§‹é€ ã§ã™ã€‚
ãŸã ã—ã€è¡¨ç¤ºã•ã‚Œãªã„ï¼ˆå…‰ã‚‰ãªã„ï¼‰åŸå› ãŒã‚ã‚‹ã¨ã™ã‚Œã°ã€ä»¥ä¸‹ã®ã„ãšã‚Œã‹ã§ã™ï¼š

âœ… flush_async() ã®ç¢ºèªã¾ã¨ã‚
è¦ç´ 	å†…å®¹	å•é¡Œã®æœ‰ç„¡
ãƒšãƒ¼ã‚¸ãƒ«ãƒ¼ãƒ—	0..16 â†’ 128px ã®ç¸¦è§£åƒåº¦ã‚’ 8px/pï¼ˆï¼16ãƒšãƒ¼ã‚¸ï¼‰ã§ã‚«ãƒãƒ¼ â†’ âœ…	
ã‚¢ãƒ‰ãƒ¬ã‚¹è¨­å®š	0xB0 + page, 0x00, 0x10 â†’ æ­£ã—ã„åˆæœŸåŒ–é † â†’ âœ…	
ãƒšãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿å–å¾—	buffer[page * 128..(page + 1) * 128] â†’ åˆç†çš„ â†’ âœ…	
ãƒãƒ£ãƒ³ã‚¯é€ä¿¡	16ãƒã‚¤ãƒˆ + åˆ¶å¾¡ãƒã‚¤ãƒˆ 0x40 ã§é€ä¿¡ â†’ âœ…	
Vec ã‚µã‚¤ã‚º	heapless::Vec<u8, 17> ã§ 16 + 1 byte â†’ âœ…	
éåŒæœŸå¯¾å¿œ	.await ã‚’ä½¿ã£ã¦ write() å‘¼ã³å‡ºã— â†’ âœ…	
â—ï¸å¯èƒ½æ€§â‘ ï¼šself.buffer ã« 0 ãŒå…¥ã£ã¦ã„ã‚‹
æç”»å‰ã«ä½•ã‚‚æ›¸ãè¾¼ã¾ã‚Œã¦ã„ãªã„å ´åˆã€ãƒãƒƒãƒ•ã‚¡ã¯ã‚¼ãƒ­ã®ã¾ã¾ã§çœŸã£é»’ã§ã™ã€‚
flush_async() ã®å•é¡Œã§ã¯ãªãã€æç”»é–¢æ•°ã§ self.buffer ãŒæ›¸ãå¤‰ã‚ã£ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

âœ… ãƒã‚§ãƒƒã‚¯æ–¹æ³•ï¼ˆãƒ†ã‚¹ãƒˆç”¨ã«å…¨ç‚¹ç¯ï¼‰
for byte in self.buffer.iter_mut() {
    *byte = 0xFF;
}
self.flush_async().await?;
â—ï¸å¯èƒ½æ€§â‘¡ï¼šåˆæœŸåŒ–ã‚³ãƒãƒ³ãƒ‰ (init_async()) ãŒä¸å®Œå…¨ã¾ãŸã¯å¤±æ•—ã—ã¦ã„ã‚‹
flush_async() ãŒæ­£ã—ãã¦ã‚‚ã€display.init_async().await? ãŒã‚³ã‚±ã¦ã„ã‚Œã°ã€ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ã¯ç„¡åå¿œã§ã™ã€‚

åˆæœŸåŒ–ã‚³ãƒãƒ³ãƒ‰ä¸­ã§ 0xAFï¼ˆDisplay ONï¼‰ã‚’é€ã£ã¦ã„ãªã„å ´åˆã‚‚åŒæ§˜ã€‚

âœ… ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆï¼š

self.send_cmd_async(0xAE).await?; // Display OFF

// ...å¿…è¦ãªåˆæœŸåŒ–ã‚³ãƒãƒ³ãƒ‰ã‚’ã™ã¹ã¦é€ã‚‹...

self.send_cmd_async(0xAF).await?; // â† Display ON ã‚’æœ€å¾Œã«é€ã£ã¦ã„ã‚‹ã‹ï¼Ÿ
â—ï¸å¯èƒ½æ€§â‘¢ï¼šI2C æ›¸ãè¾¼ã¿å¤±æ•—ï¼ˆç‰¹ã« AVR ç’°å¢ƒï¼‰
å•é¡Œã®èƒŒæ™¯
AVR (ATmega328pãªã©) ã® I2C å®Ÿè£…ã§ã¯ ä¸€åº¦ã«é€ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿é•·ã«åˆ¶é™ï¼ˆ32ãƒã‚¤ãƒˆãªã©ï¼‰ ãŒã‚ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚

flush_async() ã¯ 17ãƒã‚¤ãƒˆãšã¤ã«ãƒãƒ£ãƒ³ã‚¯ã•ã‚Œã¦ã„ã¦å¯¾å¿œæ¸ˆã®ã‚ˆã†ã«è¦‹ãˆã¾ã™ãŒã€Arduino HAL å´ãŒ .write() ã«å†…éƒ¨ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¦ã„ãªã„ã‹ç¢ºèªãŒå¿…è¦ã§ã™ã€‚

âœ… ãƒ†ã‚¹ãƒˆæ–¹æ³•
é€ä¿¡ã®å„ç®‡æ‰€ã«ãƒ­ã‚°ã‚’è¿½åŠ ã—ã¦ã¿ã¦ãã ã•ã„ï¼š

// è¿½åŠ ï¼š
defmt::info!("Sending {} bytes to {:X}", buf.len(), self.address);
ã‚ã‚‹ã„ã¯ .await? ã‚’ .await.expect("I2C write failed") ã«å¤‰ãˆã‚‹ã“ã¨ã§ panic ã‚’æ•ã¾ãˆã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

âœ… çµè«–ï¼šè¡¨ç¤ºã•ã‚Œãªã„åŸå› ã‚’åˆ‡ã‚Šåˆ†ã‘ã‚‹ã‚¹ãƒ†ãƒƒãƒ—
ãƒãƒƒãƒ•ã‚¡ã‚’ 0xFF ã§åˆæœŸåŒ–ã—ã¦ã¿ã‚‹ â†’ æœ¬å½“ã«é€ã‚Œã¦ã‚‹ã‹ç¢ºèª

flush_async() ã« panic ã‚„ Err(_) ãŒè¿”ã£ã¦ãªã„ã‹ãƒ­ã‚°å‡ºåŠ›

init_async() ã®ä¸­ã§ 0xAF ã‚’æœ€å¾Œã«é€ã£ã¦ã‚‹ã‹ãƒã‚§ãƒƒã‚¯

flush_async() ã® write() ã« .expect("write failed") ã‚’ã¤ã‘ã¦ã¿ã‚‹

æœ€çµ‚æ‰‹æ®µï¼šI2C ã®é€ä¿¡å†…å®¹ã‚’ãƒ­ã‚¸ã‚¢ãƒŠã§è¦‹ã‚‹ï¼ˆif availableï¼‰

ğŸ’¡ã‚‚ã—ã‚ˆã‘ã‚Œã° init_async() ã®ä¸­èº«ã‚‚è¦‹ã›ã¦ãã ã•ã„
flush_async() ã¯åˆæ ¼ç‚¹ã§ã™ã€‚åˆæœŸåŒ–ãŒåŸå› ã®å¯èƒ½æ€§ãŒæœ€ã‚‚é«˜ã„ã§ã™ã€‚
ã¾ãŸã€ã€ŒåŒæœŸç‰ˆã® flush()ã€ã‚‚ãŠæŒã¡ãªã‚‰ã€ãã‚Œã¨æ¯”è¼ƒã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

ã‚ãªãŸ:
/* 
  Pythonãƒ‰ãƒ©ã‚¤ãƒã¨SH1107ãƒ‡ãƒ¼ã‚¿ã‚·ãƒ¼ãƒˆã‹ã‚‰å°å‡ºã•ã‚ŒãŸã‚³ãƒãƒ³ãƒ‰åˆ—
  ã‚³ãƒãƒ³ãƒ‰ã‚’2ãƒã‚¤ãƒˆãšã¤ï¼ˆã‚³ãƒãƒ³ãƒ‰ãƒã‚¤ãƒˆ + ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒˆï¼‰é€ä¿¡
  ãŸã ã—ã€0xAE, 0x20, 0xA0, 0xC0, 0xAF ã¯å˜ç‹¬ã‚³ãƒãƒ³ãƒ‰
  ãã®ãŸã‚ã€cmds.chunks(2) ã®å‡¦ç†ã¯æ³¨æ„ãŒå¿…è¦ã€‚
  å€‹ã€…ã®ã‚³ãƒãƒ³ãƒ‰ã‚’send_commandã§é€ä¿¡ã™ã‚‹ã®ãŒã‚ˆã‚Šç¢ºå®Ÿã€‚
*/

pub const DISPLAY_OFF: u8 = 0xAE;
pub const DISPLAY_ON: u8 = 0xAF;
pub const SET_MULTIPLEX_RATIO: u8 = 0xA8;
pub const MULTIPLEX_RATIO_DATA: u8 = 0x7F;
pub const CHARGE_PUMP_ON_CMD: u8 = 0xAD;
pub const CHARGE_PUMP_ON_DATA: u8 = 0x8B;
pub const PAGE_ADDRESSING_CMD: u8 = 0x20;
pub const SEGMENT_REMAP: u8 = 0xA0;
pub const COM_OUTPUT_SCAN_DIR: u8 = 0xC0;
pub const DISPLAY_START_LINE_CMD: u8 = 0xDC;
pub const DISPLAY_START_LINE_DATA: u8 = 0x00;
pub const CONTRAST_CONTROL_CMD: u8 = 0x81;
pub const CONTRAST_CONTROL_DATA: u8 = 0x2F;
pub const DISPLAY_OFFSET_CMD: u8 = 0xD3;
pub const DISPLAY_OFFSET_DATA: u8 = 0x60;
pub const PRECHARGE_CMD: u8 = 0xD9;
pub const PRECHARGE_DATA: u8 = 0x22;
pub const VCOM_DESELECT_CMD: u8 = 0xDB;
pub const VCOM_DESELECT_DATA: u8 = 0x35;
pub const CLOCK_DIVIDE_CMD: u8 = 0xD5;
pub const CLOCK_DIVIDE_DATA: u8 = 0x51;

/// sync
#[cfg(feature = "sync")]
use embedded_hal::i2c::I2c;

#[cfg(feature = "sync")]
use crate::{cmds::*, BuilderError, Sh1107g, Sh1107gBuilder, DISPLAY_WIDTH};

#[cfg(feature = "sync")]
use core::result::Result;
#[cfg(feature = "sync")]
use core::result::Result::Ok;

// Sh1107g instance ( builded by builder ) call init and flush
#[cfg(feature = "sync")]
impl<I2C, E> Sh1107gBuilder<I2C>
where
    I2C: embedded_hal::i2c::I2c<Error = E>,
{
    /// Build Sh1107g instance
    pub fn build(self) -> Result<Sh1107g<I2C>, BuilderError> {
        let i2c = self.i2c.ok_or(BuilderError::NoI2cConnected)?;
        // let size = self.size.ok_or(BuilderError::NoDisplaySizeDefined)?; // ã‚µã‚¤ã‚ºãŒå¿…é ˆã®å ´åˆ

        // If you need, more add configure

        let oled = Sh1107g::new(i2c, self.address
            // size: size,
            // rotation: self.rotation,
            ); // Sh1107g::new init include buffer

        // display initialize ã‚„ã‚‹ã‹ã©ã†ã‹
        Ok(oled)
    }
}

// Sh1107g impl block
#[cfg(feature = "sync")]
impl<I2C, E> Sh1107g<I2C>
where
    I2C: I2c<Error = E>,
{
    /// Display initialize sequence
    pub fn init(&mut self) -> Result<(), E> {
        self.send_cmd(DISPLAY_OFF)?; // Display Off
        self.send_cmdandarg(0xD5, 0x51)?; // Set Display Clock Divide Ratio / Osc Frequency (Pythonã§0x51)
        self.send_cmdandarg(SET_MULTIPLEX_RATIO, MULTIPLEX_RATIO_DATA)?; // Set Multiplex Ratio (128è¡Œå¯¾å¿œ)
        self.send_cmdandarg(DISPLAY_OFFSET_CMD, DISPLAY_OFFSET_DATA)?; // Set Display Offset (Pythonã§0x60)
        self.send_cmdandarg(CHARGE_PUMP_ON_CMD, CHARGE_PUMP_ON_DATA)?; // Set Charge Pump (Pythonã§0x8B, ãƒ‡ãƒ¼ã‚¿ã‚·ãƒ¼ãƒˆã§ã¯8BhãŒEnable)
        self.send_cmdandarg(0xDA, 0x12)?; // Set COM Pins Hardware Config (Pythonã§0x12)
        self.send_cmd(PAGE_ADDRESSING_CMD)?; // Set Memory Addressing Mode (Page Addressing Mode)
        self.send_cmd(CONTRAST_CONTROL_CMD)?; // Set Contrast Control
        self.send_cmdandarg(CONTRAST_CONTROL_CMD, CONTRAST_CONTROL_DATA)?; // Contrast Control (0x2Fã¯ä¸€èˆ¬çš„ãªå€¤)
        self.send_cmd(0xA0)?; // Set Segment Remap (é€šå¸¸ã¯A0hã‹A1h)
        self.send_cmd(0xC0)?; // Set COM Output Scan Direction (C0h: Normal, C8h: Re-mapped)
        self.send_cmdandarg(0xD9, 0x22)?; // Set Pre-charge Period
        self.send_cmdandarg(0xDB, 0x35)?; // Set VCOM Deselect Level
        self.send_cmd(0xA4)?; // Set Entire Display ON / OFF (A4h: Normal Display)
        self.send_cmd(0xA6)?; // Set Normal / Inverse Display (A6h: Normal)
        self.send_cmd(DISPLAY_ON)?; // Display ON

        Ok(())
    }

    /// IIC write command byte
    fn send_cmd(&mut self, cmd: u8) -> Result<(), E> {
        self.i2c.write(self.address, &[0x00, cmd])
    }

    /// IIC write command byte and data byte
    fn send_cmdandarg(&mut self, cmd: u8, arg: u8) -> Result<(), E> {
        self.i2c.write(self.address, &[0x00, cmd, arg])
    }

    /// Rendering
    // Send self internal buffer
    pub fn flush(&mut self) -> Result<(), E> {
        // SH1107G is page addressing mode and 128 byte/page
        // 128/8 = 16 page because 128x128 pixels
        for page in 0..16 { // 0 to 15
            self.send_cmd(0xB0 + page)?; // Set Page Address (B0h ~ BFh)
            self.send_cmd(0x00)?; // Set Lower Column Address (0x00)
            self.send_cmd(0x10)?; // Set Higher Column Address (0x10)

            // buffer ã¯2048ãƒã‚¤ãƒˆå…¨ä½“ã§ã€å„ãƒšãƒ¼ã‚¸128ãƒã‚¤ãƒˆãªã®ã§
            // buffer[page * 128 .. (page + 1) * 128] ã§è©²å½“ãƒšãƒ¼ã‚¸ã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚’å–å¾—

            // Cast to usize and perform calculation
            let page_usize = page as usize;
            let width_usize = DISPLAY_WIDTH as usize;

            let start_index = page_usize * (width_usize / 8);
            let end_index = (page_usize + 1) * (width_usize / 8);

            // ã‚¹ãƒ©ã‚¤ã‚¹ã‚‚usizeã®ç¯„å›²ã§æŒ‡å®š
            // å†…éƒ¨ãƒãƒƒãƒ•ã‚¡ä¿æŒ
            let page_data = &self.buffer[start_index..end_index];

            // I2Cã®writeã¯1å›ã®å‘¼ã³å‡ºã—ã§é€ä¿¡ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿é‡ã«åˆ¶é™ãŒã‚ã‚‹å ´åˆãŒã‚ã‚‹ãŸã‚ã€
            // 16ãƒã‚¤ãƒˆãšã¤åˆ†å‰²ã—ã¦é€ä¿¡ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã¯ç†ã«ã‹ãªã£ã¦ã„ã‚‹ã€‚
            // å„ãƒšãƒ¼ã‚¸ã®ãƒ‡ãƒ¼ã‚¿ã‚’16ãƒã‚¤ãƒˆãƒãƒ£ãƒ³ã‚¯ã§é€ä¿¡
            for chunk in page_data.chunks(16) {
                let mut buf: heapless::Vec<u8, 17> = heapless::Vec::new(); // åˆ¶å¾¡ãƒã‚¤ãƒˆ1 + ãƒ‡ãƒ¼ã‚¿æœ€å¤§16ãƒã‚¤ãƒˆ
                buf.push(0x40).unwrap(); // control byte for data (0x40)
                buf.extend_from_slice(chunk).unwrap();
                self.i2c.write(self.address, &buf)?;
            }
        }
        Ok(())
    }
}
ChatGPT:
ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€ã‚³ãƒ¼ãƒ‰ã¨æƒ…å ±ã‚’ç¢ºèªã—ã¾ã—ãŸã€‚ä»¥ä¸‹ã¯ã€SH1107G ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ãŒç‚¹ç¯ã—ãªã„å¯èƒ½æ€§ã®ã‚ã‚‹åŸå› ã¨ã€ãã‚Œã«å¯¾ã™ã‚‹æ”¹å–„æ¡ˆãƒ»æ¤œè¨¼ãƒã‚¤ãƒ³ãƒˆã§ã™ã€‚

âœ… ã‚³ãƒ¼ãƒ‰ä¸Šã®è‰¯ã„ç‚¹
ãƒ‡ãƒ¼ã‚¿ã‚·ãƒ¼ãƒˆã¨Pythonå®Ÿè£…ã«å¿ å®Ÿã§ã€åˆæœŸåŒ–æ‰‹é †ã¯ã»ã¼å•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚

send_cmd() ã¨ send_cmdandarg() ã‚’æ˜ç¢ºã«ä½¿ã„åˆ†ã‘ã¦ã„ã‚‹ã€‚

flush() å†…ã® page æ›¸ãè¾¼ã¿ãƒ­ã‚¸ãƒƒã‚¯ã‚‚æ­£ã—ã„ï¼ˆSH1107 ã¯ãƒšãƒ¼ã‚¸ã‚¢ãƒ‰ãƒ¬ãƒƒã‚·ãƒ³ã‚°ï¼‰ã€‚

I2C ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ 0x3C ã«ã—ã¦ã„ã‚‹ï¼ˆi2cdetect ã«ã‚‚å¿œç­”ã‚ã‚Šï¼‰ã€‚

âš ï¸ å®Ÿæ©ŸãŒå…‰ã‚‰ãªã„åŸå› å€™è£œã¨æ”¹å–„ç­–
1. DISPLAY_OFFSET ãŒå¤§ãã™ãã‚‹
self.send_cmdandarg(DISPLAY_OFFSET_CMD, 0x60)?; // Pythonã§ã¯0x60
ğŸ§ª å¯¾ç­–ï¼š
ã¾ãš 0x00 ã«ã—ã¦è©¦ã—ã¦ã¿ã¦ãã ã•ã„ã€‚

0x60 ã¯ã€Œãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤RAMã®å§‹ç‚¹ã‚’ç‰©ç†ä½ç½®ã‹ã‚‰ãšã‚‰ã™ã€ã¨ã„ã†æ„å‘³ã§ã€SH1107G ã§ã¯å®Ÿè£…ä¾å­˜ã§ã™ã€‚

ä¸€èˆ¬çš„ã«ã¯ 0x00 or 0x20 ãã‚‰ã„ãŒç„¡é›£ã§ã™ã€‚

2. CHARGE_PUMP ã® 0x8B ãŒ Seeed è£½ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«æœªå¯¾å¿œã®å¯èƒ½æ€§
self.send_cmdandarg(CHARGE_PUMP_ON_CMD, 0x8B)?;
ğŸ§ª å¯¾ç­–ï¼š
å…¬å¼ãƒ‡ãƒ¼ã‚¿ã‚·ãƒ¼ãƒˆã§ã¯ 0x8B = å†…è”µ + è‡ªå‹•åˆ¶å¾¡ã€‚

ä»£ã‚ã‚Šã« 0x14ï¼ˆå†…è”µ VCCï¼‰ ã‚’è©¦ã™ï¼š

self.send_cmdandarg(CHARGE_PUMP_ON_CMD, 0x14)?;
3. åˆæœŸåŒ–é †åºã®å¾®èª¿æ•´
ä¸€éƒ¨ã®OLEDã§ã¯ DISPLAY_ON ã‚’æ—©ãå‘¼ã¶ã¨å‹•ã‹ãªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚

ğŸ§ª å¯¾ç­–ï¼š
DISPLAY_ON ã¯æœ€å¾Œã«ã€‚

ä¸€æ–¹ DISPLAY_OFF ã¯ä¸€ç•ªæœ€åˆã§å•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚

4. flush() å®Ÿè¡Œå‰ã« init() æ¸ˆã¿ã‹
æç”»ã—ã‚ˆã†ã¨ã—ã¦ã‚‚åˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„ã¨ä½•ã‚‚èµ·ãã¾ã›ã‚“ã€‚

ğŸ§ª å¯¾ç­–ï¼š
build() ã—ãŸå¾Œã€init() ã‚’å¿…ãšæ˜ç¤ºçš„ã«å‘¼ã¶ã€‚

let mut display = builder.build().unwrap();
display.init().unwrap();
5. I2Cé€šä¿¡ãŒé€”ä¸­ã§æ­¢ã¾ã£ã¦ã„ã‚‹
ç‰¹ã« heapless::Vec ã® unwrap() ã« .ok() ã‚’ä½¿ã‚ãšã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¦ã„ã‚‹å¯èƒ½æ€§ã€‚

ğŸ§ª å¯¾ç­–ï¼š
ä¸€æ™‚çš„ã« unwrap() ã‚’ expect("I2C write failed") ã«å¤‰æ›´ã—ã¦ãƒ‡ãƒãƒƒã‚°ã€‚

6. ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆè¨­å®šï¼ˆ0x2Fï¼‰ãŒä½ã™ãã‚‹ï¼Ÿ
0x2F ã¯ã‹ãªã‚Šæš—ã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚

ğŸ§ª å¯¾ç­–ï¼š
è©¦ã—ã« 0xFF ã«ã—ã¦ã¿ã¦ãã ã•ã„ï¼š

self.send_cmdandarg(CONTRAST_CONTROL_CMD, 0xFF)?;
7. Pull-up æŠµæŠ—ãŒè¶³ã‚Šãªã„
Groveã‚±ãƒ¼ãƒ–ãƒ«ã¯å†…éƒ¨ã«ãƒ—ãƒ«ã‚¢ãƒƒãƒ—ãŒã‚ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ãŒã€ãªã„å ´åˆã¯ SCL/SDA ã« 4.7kÎ©ï½10kÎ©ã®ãƒ—ãƒ«ã‚¢ãƒƒãƒ—æŠµæŠ—ãŒå¿…è¦ã§ã™ã€‚

âœ… ç¢ºèªã™ã¹ãã“ã¨ä¸€è¦§ï¼ˆToDoï¼‰
é …ç›®	ç¾çŠ¶	ç¢ºèª or ä¿®æ­£å†…å®¹
I2Cã‚¢ãƒ‰ãƒ¬ã‚¹	0x3C	i2cdetect ã§å¿œç­”ã‚ã‚Š â†’ OK
åˆæœŸåŒ–ã‚³ãƒãƒ³ãƒ‰	ãƒ‡ãƒ¼ã‚¿ã‚·ãƒ¼ãƒˆï¼‹Pythonæº–æ‹ 	DISPLAY_OFFSET ã‚’ 0x00 ã«å¤‰ãˆã‚‹
Charge Pump	0x8B	0x14 ã§ã‚‚è©¦ã™
ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆ	0x2F	0xFF ã«ã—ã¦å¤‰åŒ–ã‚’ç¢ºèª
Flush	æ›¸ãè¾¼ã¿æ¸ˆã¿	init() ã®å‘¼ã³å‡ºã—å¿˜ã‚Œãªã—ï¼Ÿ
ãƒ—ãƒ«ã‚¢ãƒƒãƒ—æŠµæŠ—	ä¸æ˜	å›è·¯å›³ã¾ãŸã¯ãƒ†ã‚¹ã‚¿ãƒ¼ã§ç¢ºèª
ğŸ”§ æœ€å°å†ç¾ã‚³ãƒ¼ãƒ‰ï¼ˆinitã ã‘ã§è¡¨ç¤ºç¢ºèªï¼‰
let mut display = builder.build().unwrap();
display.init().unwrap();

for i in 0..=2047 {
    display.buffer[i] = 0xFF; // å…¨é¢ç™½
}
display.flush().unwrap();
å¿…è¦ã§ã‚ã‚Œã° init() ã® I2C ãƒ­ã‚°å‡ºåŠ›ã‚„ã€oscilloscope çš„ãª I2Cãƒ¢ãƒ‹ã‚¿ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚‚ã§ãã¾ã™ã€‚

ã‚‚ã—ä¸Šè¨˜è©¦ã—ã¦ã‚‚ãƒ€ãƒ¡ã ã£ãŸã‚‰ã€init() ã®å‘¼ã³å‡ºã—ç›´å¾Œã« flush() ã—ã¦ å…¨ç™½è¡¨ç¤º ãŒå‡ºã‚‹ã‹ç¢ºèªã—ã¦æ•™ãˆã¦ãã ã•ã„ã€‚

ã‚ãªãŸ:
field buffer of Sh1107g is privaterust-analyzerE0616
field buffer of struct Sh1107g is private
private fieldrustcClick for full compiler diagnostic
sh1107g_rs::Sh1107g
buffer: [u8; BUFFER_SIZE]
I2C = I2c<Atmega, TWI, Pin<â€¦, â€¦>, â€¦, â€¦>

ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå´ã§pub æŒ‡å®šã—ã¦ã‚‹ã‚“ã§ã™ãŒ
ChatGPT:
rust-analyzer ã‚„ rustc ãŒã€Œbuffer ã¯ privateã€ã¨è¨€ã£ã¦ãã‚‹åŸå› ã¯ã€Sh1107g æ§‹é€ ä½“ã® buffer ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã« pub ãŒæ­£ã—ãä»˜ã„ã¦ã„ãªã„ã‹ã€å¯è¦–æ€§ãŒåˆ¶é™ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã§ã™ã€‚

âœ… ãƒã‚§ãƒƒã‚¯ã™ã¹ãã“ã¨
1. å®šç¾©å…ƒã® Sh1107g æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã« pub ãŒä»˜ã„ã¦ã„ã‚‹ã‹ï¼Ÿ
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ãªã„ã¨ã„ã‘ã¾ã›ã‚“ï¼š

pub struct Sh1107g<I2C> {
    pub buffer: [u8; BUFFER_SIZE], // â†ã“ã‚ŒãŒå¿…è¦
    pub i2c: I2C,
    pub address: u8,
}
ã‚‚ã— pub(crate) ã‚„ pub(super) ãªã©ã§å®£è¨€ã•ã‚Œã¦ã„ã‚‹ã¨ã€å¤–ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“ã€‚

2. mod ã‚„ use ã®éšå±¤ã‹ã‚‰è¦‹ã¦ã€Sh1107g æ§‹é€ ä½“ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å¯è¦–æ€§ã®å•é¡ŒãŒãªã„ã‹ï¼Ÿ
ãŸã¨ãˆã°ã€Sh1107g ãŒ driver ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ã‚‹å ´åˆã€ä»¥ä¸‹ã®ã‚ˆã†ã« use ã—ã¦ã„ã¦ã‚‚ buffer ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ï¼š

// NGä¾‹ï¼šbuffer ãŒ pub ã§ãªã„ã¨ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„
use crate::driver::Sh1107g;

fn foo(oled: &mut Sh1107g<_>) {
    oled.buffer[..]; // â†ã‚¨ãƒ©ãƒ¼
}
ğŸ§ª è§£æ±ºæ³•
âœ… æ–¹æ³•1: buffer ã‚’ pub ã«ã™ã‚‹
pub struct Sh1107g<I2C> {
    pub buffer: [u8; BUFFER_SIZE], // â†ã“ã‚Œï¼
    // ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
}
âœ… æ–¹æ³•2: flush() ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¸­ã§ buffer ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã‚ˆã†ã«ã—ã¦ã€å¤–ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã—ãªã„
impl<I2C, E> Sh1107g<I2C>
where
    I2C: I2c<Error = E>,
{
    pub fn flush(&mut self) -> Result<(), E> {
        // self.buffer ã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãªã‚‰ pub ã¯ä¸è¦
    }
}
ğŸ“Œ è£œè¶³ï¼šè¨­è¨ˆçš„ã«æ­£ã—ã„ã®ã¯ï¼Ÿ
ä¸€èˆ¬çš„ã«ã€buffer ã¯ å¤–éƒ¨ã‹ã‚‰ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã•ã›ãšã€flush() ãªã©ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’é€šã˜ã¦æ‰±ã†æ–¹ãŒå®‰å…¨ã§ã™ã€‚
ãã®ãŸã‚ã€ä»¥ä¸‹ã®è¨­è¨ˆãŒãŠã™ã™ã‚ã§ã™ï¼š

struct Sh1107g<I2C> {
    buffer: [u8; BUFFER_SIZE], // pub ã«ã—ãªã„
    i2c: I2C,
    address: u8,
}

impl<I2C, E> Sh1107g<I2C> {
    pub fn update_buffer(&mut self, new: &[u8]) {
        self.buffer.copy_from_slice(new);
    }

    pub fn flush(&mut self) -> Result<(), E> {
        // buffer ã«å†…éƒ¨ã§ã‚¢ã‚¯ã‚»ã‚¹
    }
}
ã‚‚ã— pub ã«ã—ã¦ã„ã‚‹ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚‹ã®ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„ã¨ã„ã†å ´åˆã¯ã€è©²å½“éƒ¨åˆ†ã®ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã›ã¦ãã‚ŒãŸã‚‰ãƒ”ãƒ³ãƒã‚¤ãƒ³ãƒˆã§ç¢ºèªã§ãã¾ã™ã€‚

ã‚ãªãŸ:
#![no_std]
/// SH1107G I2C OLED driver
pub mod cmds;

#[cfg(feature = "sync")]
pub mod sync;

#[cfg(feature = "async_")]
pub mod async_;

use embedded_graphics_core::{
    draw_target::DrawTarget,
    pixelcolor::BinaryColor,
    Pixel,
};
use core::convert::Infallible;
use core::result::Result;
use core::option::Option::{self, Some, None};
use core::result::Result::Ok;
use core::fmt::Debug;
use core::iter::IntoIterator;

/*
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DisplayRotation {
    Rotate0,
    Rotate90,
    Rotate180,
    Rotate270,
}

// Default process
impl Default for DisplayRotation {
    fn default() -> Self {
        DisplayRotation::Rotate0
    }
}
*/

/// common
use embedded_graphics_core::geometry::{Dimensions, Point, Size};

pub struct Sh1107g<I2C> {
    i2c: I2C,
    address: u8,
    buffer: [u8; BUFFER_SIZE], // Internal buffer
    // Configure in builder to Sh1107g struct
}

impl <I2C> Sh1107g<I2C> {
    // Make new driver instance & Degine function called by the builder
    // Initialise the internal buffer when called by builder
    pub fn new(i2c: I2C, address: u8) -> Self {
        Self {
            i2c,
            address,
            buffer: [0x00; BUFFER_SIZE], // å…¨ã¦ã‚ªãƒ•ã§åˆæœŸåŒ–
        }
    }

    /// å†…éƒ¨ãƒãƒƒãƒ•ã‚¡ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹
    pub fn clear_buffer(&mut self) {
        self.buffer.iter_mut().for_each(|b| *b = 0x00);
    }
}
// Builder struct
pub struct Sh1107gBuilder<I2C> {
    i2c: Option<I2C>,
    address: u8,      // Configure default address or choice Option type
    // If you can add more settings value rotation: DisplayRotation,etc...
}

// Sh1107gBuilder implement block
impl<I2C> Sh1107gBuilder<I2C> {
    /// Make new builder instance
    /// Designation default I2C address
    pub fn new() -> Self {
        Self {
            i2c: None,
            address: 0x3C, // default
            // size: None,
            // rotation: DisplayRotation::default(),
        }
    }

    /// Connect I2C
    pub fn connect_i2c(mut self, i2c: I2C) -> Self {
        self.i2c = Some(i2c);
        self
    }

    /// Configure I2C address
    pub fn with_address(mut self, address: u8) -> Self {
        self.address = address;
        self
    }

    // If you need other method, add other setting method, example: size,rotate,etc...
}

// Define error enum in builder
#[derive(Debug)]
pub enum BuilderError {
    NoI2cConnected,
    // NoDisplaySizeDefined, // ã‚µã‚¤ã‚ºãŒå¿…é ˆã®å ´åˆ
}
// embedded-halã®Errorãƒˆãƒ¬ã‚¤ãƒˆã«ã‚‚å¯¾å¿œã•ã›ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“
// impl embedded_hal::i2c::Error for BuilderError { ... }
// impl From<BuilderError> for YourDriverError { ... } ãªã©

// define display size
pub const DISPLAY_WIDTH: u32 = 128;
pub const DISPLAY_HEIGHT: u32 = 128;
pub const BUFFER_SIZE: usize = (DISPLAY_WIDTH * DISPLAY_HEIGHT / 8) as usize;

// Sh1107g ã« Dimensions ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…
impl<I2C> Dimensions for Sh1107g<I2C> {
    fn bounding_box(&self) -> embedded_graphics_core::primitives::Rectangle {
        embedded_graphics_core::primitives::Rectangle::new(
            Point::new(0, 0),
            Size::new(DISPLAY_WIDTH, DISPLAY_HEIGHT),
        )
    }
}

impl<I2C> DrawTarget for Sh1107g<I2C> {
    // DrawTarget define color dimension (monochro OLED = BinaryColor)
    type Color = BinaryColor;
    type Error = Infallible; // embedded-halã®I2Cã‚¨ãƒ©ãƒ¼ã‚’ãã®ã¾ã¾ä½¿ã†
    
    /// ãƒ”ã‚¯ã‚»ãƒ«ã‚’æç”»ã™ã‚‹ä¸»è¦ãªãƒ¡ã‚½ãƒƒãƒ‰
    fn draw_iter<PIXELS>(&mut self, pixels: PIXELS) -> Result<(), Self::Error>
    where
        PIXELS: IntoIterator<Item = Pixel<Self::Color>>,
    {
        for Pixel(Point { x, y }, color) in pixels {
            // åº§æ¨™ãŒãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ç¯„å›²å†…ã‹ãƒã‚§ãƒƒã‚¯
            if x < 0 || x >= DISPLAY_WIDTH as i32 || y < 0 || y >= DISPLAY_HEIGHT as i32 {
                continue; // ç¯„å›²å¤–ã®ãƒ”ã‚¯ã‚»ãƒ«ã¯ã‚¹ã‚­ãƒƒãƒ—
            }

            // ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ã‹ã‚‰ãƒãƒƒãƒ•ã‚¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ãƒ“ãƒƒãƒˆãƒã‚¹ã‚¯ã‚’è¨ˆç®—
            // SH1107Gã¯ãƒšãƒ¼ã‚¸ã‚¢ãƒ‰ãƒ¬ãƒƒã‚·ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã€å„ãƒã‚¤ãƒˆãŒç¸¦8ãƒ”ã‚¯ã‚»ãƒ«
            let byte_index = (x as usize) + (y as usize / 8) * (DISPLAY_WIDTH as usize);
            let bit_mask = 1 << (y % 8); // ãƒã‚¤ãƒˆå†…ã®ãƒ“ãƒƒãƒˆä½ç½®

            // ãƒãƒƒãƒ•ã‚¡ã®ç¯„å›²ãƒã‚§ãƒƒã‚¯ï¼ˆå¿µã®ãŸã‚ï¼‰
            if byte_index >= BUFFER_SIZE {
                continue; // ãƒãƒƒãƒ•ã‚¡ç¯„å›²å¤–ã‚‚ã‚¹ã‚­ãƒƒãƒ—
            }

            // è‰²ã«å¿œã˜ã¦ãƒãƒƒãƒ•ã‚¡ã®ãƒ“ãƒƒãƒˆã‚’ã‚»ãƒƒãƒˆã¾ãŸã¯ã‚¯ãƒªã‚¢
            match color {
                BinaryColor::On => self.buffer[byte_index] |= bit_mask,  // ãƒ”ã‚¯ã‚»ãƒ«ã‚’ON (ã‚»ãƒƒãƒˆ)
                BinaryColor::Off => self.buffer[byte_index] &= !bit_mask, // ãƒ”ã‚¯ã‚»ãƒ«ã‚’OFF (ã‚¯ãƒªã‚¢)
            }
        }
        Ok(())
    }

    /// Fill in with color
    fn clear(&mut self, color: Self::Color) -> Result<(), Self::Error> {
        let fill_byte = match color {
            BinaryColor::On => 0xFF,
            BinaryColor::Off => 0x00,
        };
        self.buffer.iter_mut().for_each(|b| *b = fill_byte);
        Ok(())
    }
}
ChatGPT:
buffer ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ private ã§ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„ã¨ã„ã†ã‚¨ãƒ©ãƒ¼ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚±ãƒ¼ã‚¹ã§ç™ºç”Ÿã—ã¾ã™ï¼š

âœ… åŸå› 
pub struct Sh1107g<I2C> {
    i2c: I2C,
    address: u8,
    buffer: [u8; BUFFER_SIZE], // â† pub ãŒã¤ã„ã¦ã„ãªã„ãŸã‚ private æ‰±ã„
}
ã¤ã¾ã‚Šã€buffer ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ pub ã§ã¯ãªã„ãŸã‚ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å¤–ï¼ˆä¾‹ï¼šasync_ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„ã®ãŒåŸå› ã§ã™ã€‚

âœ… å¯¾å‡¦æ³• 3ã¤
â‘  æœ€ã‚‚ç°¡å˜ãªå¯¾å¿œï¼špub(crate) ã«ã™ã‚‹
ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå†…ã§ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã„å ´åˆã¯ã€ã“ã‚Œã§OKï¼š

pub(crate) buffer: [u8; BUFFER_SIZE],
ã“ã‚Œã«ã‚ˆã‚Šã€åŒã˜ã‚¯ãƒ¬ãƒ¼ãƒˆå†…ï¼ˆ= sh1107g-rs ã®ä¸­ï¼‰ã§ã‚ã‚Œã° async_ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãªã©ã‹ã‚‰ buffer ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

â‘¡ å®Œå…¨ã«å…¬é–‹ã—ãŸã„ãªã‚‰ï¼špub ã«ã™ã‚‹
pub buffer: [u8; BUFFER_SIZE],
âš  ãŸã ã—ã“ã‚Œã¯ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªä½¿ç”¨è€…ï¼ˆå¤–éƒ¨ crateï¼‰ã«ã‚‚å®Œå…¨ã«å…¬é–‹ã•ã‚Œã¦ã—ã¾ã†ã®ã§æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚

â‘¢ getter ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã™ã‚‹
ã‚‚ã—å¤–ã‹ã‚‰èª­ã¿å–ã‚Šå°‚ç”¨ã§ä½¿ã„ãŸã„ã ã‘ãªã‚‰ï¼š

impl<I2C> Sh1107g<I2C> {
    pub fn buffer(&self) -> &[u8] {
        &self.buffer
    }

    pub fn buffer_mut(&mut self) -> &mut [u8] {
        &mut self.buffer
    }
}
âœ… æ¨å¥¨ã•ã‚Œã‚‹æ–¹é‡
ãƒ©ã‚¤ãƒ–ãƒ©ãƒªè¨­è¨ˆã®è¦³ç‚¹ã‹ã‚‰ï¼š
ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå†…éƒ¨ã ã‘ã§ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã„ â†’ pub(crate)

æœ¬å½“ã«å¤–éƒ¨ crate ã«ã‚‚å…¬é–‹ã—ãŸã„ â†’ pub

èª­ã¿å–ã‚Šã‚„æ›¸ãè¾¼ã¿ã‚’åˆ¶é™ã—ãŸã„ â†’ getter/setter ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¨­ã‘ã‚‹

ğŸ›  ä¾‹ï¼špub(crate) ã«å¤‰æ›´
pub struct Sh1107g<I2C> {
    pub(crate) i2c: I2C,
    pub(crate) address: u8,
    pub(crate) buffer: [u8; BUFFER_SIZE], // â† ã“ã‚Œ
}
ã“ã®ã‚ˆã†ã«ã™ã‚Œã°ã€mod async_ å†…ã® flush_async é–¢æ•°ã‹ã‚‰ self.buffer[...] ã‚’å•é¡Œãªãä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

å¿…è¦ã§ã‚ã‚Œã°ã€flush_async ã‚’å®šç¾©ã—ã¦ã„ã‚‹ async_ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã®ä¾å­˜é–¢ä¿‚ã‚„ mod.rs æ§‹æˆã«ã¤ã„ã¦ã‚‚è¦‹ç›´ã™ã“ã¨ã¯æœ‰ç›Šã§ã™ã€‚å¸Œæœ›ãŒã‚ã‚Œã°ãã®éƒ¨åˆ†ã‚‚ç¢ºèªã—ã¾ã™ã€‚

ã‚ãªãŸ:
 // Each page is 128 bytes. Get the slice for the current page.
            let page_usize = page as usize;
            let width_usize = DISPLAY_WIDTH as usize;
            // Calculate start and end indices for the current page.
            let start_index = page_usize * width_usize;
            let end_index = (page_usize + 1) * width_usize;
ã¨ã„ã£ãŸææ¡ˆã‚‚ã•ã‚Œã¦ã„ã¾ã™
ChatGPT:
ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚çŠ¶æ³ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«æ•´ç†ã§ãã¾ã™ï¼š

â— ç¾åœ¨ã®å•é¡Œ
ã‚³ãƒ¼ãƒ‰ã¯ãƒ“ãƒ«ãƒ‰ã§ãã€I2C ã‚¢ãƒ‰ãƒ¬ã‚¹ 0x3C ã«å¿œç­”ã‚‚ã‚ã‚‹ãŒã€SH1107G OLED ãŒå…¨ãå…‰ã‚‰ãªã„ã€‚

âœ… ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ãƒã‚§ãƒƒã‚¯æ¸ˆã¿é …ç›®
I2C æ¥ç¶šã¯ 0x3C ã«åå¿œã—ã¦ã„ã‚‹ â†’ OK

init() â†’ flush() å‘¼ã³å‡ºã—ã‚ã‚Š â†’ OK

display ã« Text::new(...).draw(...) â†’ OK

sh1107g_rs ãƒ‰ãƒ©ã‚¤ãƒã¯è‡ªä½œä¸­ â†’ OK

âœ… ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢æ§‹é€ ã®ç¾çŠ¶
Sh1107g<I2C> ã® buffer ã¯ DrawTarget ã¨ clear ã«ã‚ˆã‚Šæ“ä½œã•ã‚Œã¦ã„ã‚‹

flush() ã‚’å‘¼ã¶ã“ã¨ã§ buffer â†’ ãƒ‡ãƒã‚¤ã‚¹ ã«è»¢é€ã•ã‚Œã‚‹æƒ³å®š

ãŸã ã—ã€å®Ÿéš›ã«ãƒ‡ãƒã‚¤ã‚¹ã«ä½•ã‚‚é€ã£ã¦ã„ãªã„å¯èƒ½æ€§ãŒé«˜ã„

ğŸ› ï¸ æ ¹æœ¬çš„ãªåŸå› 
ãŠãã‚‰ãæ¬¡ã®2ç‚¹ã®ã†ã¡å°‘ãªãã¨ã‚‚1ã¤ï¼š

â‘  flush() ã®å®Ÿè£…ãŒã¾ã å­˜åœ¨ã—ãªã„ã€ã‚ã‚‹ã„ã¯ draw() ã§å¤‰æ›´ã•ã‚ŒãŸ buffer ã‚’ OLED ã«åæ˜ ã—ã¦ã„ãªã„
display.flush().unwrap();
ã“ã‚Œã¯ Sh1107g<I2C> ã® flush() ãƒ¡ã‚½ãƒƒãƒ‰ã§ self.buffer ã‚’ I2C ã§é€ä¿¡ã™ã‚‹å‡¦ç†ãŒæ›¸ã‹ã‚Œã¦ã„ã‚‹ å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ã—ã‹ã—ã€ã‚ãªãŸã®æç¤ºã—ã¦ãã‚ŒãŸã‚³ãƒ¼ãƒ‰ä¸­ã« flush() ã®å®šç¾©ãŒè¦‹å½“ãŸã‚Šã¾ã›ã‚“ã€‚

âœ… å¯¾å¿œç­–ï¼šflush() å®Ÿè£…ã®è¿½åŠ 
Sh1107g æ§‹é€ ä½“ã« flush() ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ãã ã•ã„ï¼š

use embedded_hal::blocking::i2c::Write;

impl<I2C, E> Sh1107g<I2C>
where
    I2C: Write<Error = E>,
{
    pub fn flush(&mut self) -> Result<(), E> {
        for page in 0..(DISPLAY_HEIGHT / 8) {
            let page = page as u8;
            let cmds = [
                0xB0 + page,        // Set page start address
                0x02,               // Lower column address
                0x10,               // Higher column address
            ];
            self.i2c.write(self.address, &cmds)?;

            let start = (page as usize) * DISPLAY_WIDTH as usize;
            let end = start + DISPLAY_WIDTH as usize;

            // OLEDã«æ›¸ãè¾¼ã‚€éš›ã¯ã€0x40ã‚’ãƒ‡ãƒ¼ã‚¿ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒã‚¤ãƒˆã¨ã—ã¦å…ˆé ­ã«ä»˜åŠ 
            let mut data = [0u8; 1 + DISPLAY_WIDTH as usize];
            data[0] = 0x40; // Co = 0, D/C# = 1
            data[1..].copy_from_slice(&self.buffer[start..end]);

            self.i2c.write(self.address, &data)?;
        }

        Ok(())
    }
}
ğŸ§ª flush() å®Ÿè£…å¾Œã®å‹•ä½œç¢ºèª
æ›¸ãè¾¼ã¿å‰ã«ç”»é¢ã‚¯ãƒªã‚¢ï¼ˆå…¨æ¶ˆç¯ï¼‰ã—ã¦ã¿ã¦ï¼š
display.clear(BinaryColor::Off).unwrap();
display.flush().unwrap();
arduino_hal::delay_ms(1000);
ãã®å¾Œã«ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º
Text::new("Hello!", Point::new(16, 16), text_style)
    .draw(&mut display)
    .unwrap();
display.flush().unwrap();
ğŸ”’ buffer ãŒ private ã§è§¦ã‚Œãªã„ä»¶
ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå´ã§ pub æŒ‡å®šã—ã¦ã‚‹ã‚“ã§ã™ãŒ

ãã‚Œã¯ Sh1107gBuilder ã‚„ DrawTarget å®Ÿè£…ãªã©ã§ã®ã¿ä½¿ã‚ã‚Œã¦ãŠã‚Šã€å¤–éƒ¨ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã«ã¯ï¼š

pub buffer: [u8; BUFFER_SIZE],
ã¨æ›¸ãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ãŸã ã—ã€æœ¬æ¥ buffer ã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã›ãš flush() ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚

âœ… çµè«–
ä»Šå…‰ã‚‰ãªã„æœ€å¤§ã®ç†ç”±ã¯ flush() ãŒæœªå®Ÿè£… ã¾ãŸã¯ buffer â†’ OLED è»¢é€å‡¦ç†ãŒæ¬ ã‘ã¦ã„ã‚‹ ã“ã¨ã§ã™ã€‚

ä¸Šè¨˜ã® flush() å®Ÿè£…ã‚’çµ„ã¿è¾¼ã‚ã°ã€è¡¨ç¤ºãŒå‹•ä½œã™ã‚‹å¯èƒ½æ€§ãŒéå¸¸ã«é«˜ã„ã§ã™ã€‚

å¿…è¦ãªã‚‰ init() ã® I2C ã‚³ãƒãƒ³ãƒ‰ç¾¤ï¼ˆåˆæœŸåŒ–ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ï¼‰ã‚‚ç¢ºèªã—ã¾ã™ã€‚è©¦ã—ã¦ã¿ã¦ãã ã•ã„ã€‚
